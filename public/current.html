<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Current Focus Feed</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
    }

    #feed {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      background: transparent;
      transition: opacity 120ms ease;
      opacity: 0;
      visibility: hidden;
    }
  </style>
</head>
<body>
  <div class="stage">
    <video id="feed" autoplay playsinline muted></video>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const video = document.getElementById("feed");
      const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

      let ws;
      let wsReady = false;
      let viewerRegistered = false;
      let reconnectTimer = null;
      let connectionCounter = 0;

      const knownPublishers = new Set();
      const sessions = new Map();

      let desiredFocus = null;
      let displayedStream = null;
      let displayedNickname = null;

      function normalizeNickname(name) {
        if (typeof name !== "string") {
          return null;
        }
        const trimmed = name.trim();
        return trimmed.length ? trimmed : null;
      }

      function createConnectionId() {
        connectionCounter += 1;
        return `viewer-${Date.now()}-${connectionCounter}`;
      }

      function setDisplay(stream, nickname) {
        displayedStream = stream || null;
        displayedNickname = nickname || null;

        if (video.srcObject !== stream) {
          video.srcObject = stream || null;
        }

        if (stream) {
          video.style.opacity = "1";
          video.style.visibility = "visible";
        } else {
          video.style.opacity = "0";
          video.style.visibility = "hidden";
        }
      }

      function updateDisplay() {
        if (!desiredFocus) {
          setDisplay(null, null);
          return;
        }

        const session = sessions.get(desiredFocus);
        if (session?.stream) {
          setDisplay(session.stream, session.nickname);
        } else {
          setDisplay(null, null);
        }
      }

      function sendSignal(payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(payload));
        }
      }

      function cleanupSession(nickname, { notify = true } = {}) {
        const session = sessions.get(nickname);
        if (!session) {
          return;
        }

        sessions.delete(nickname);

        if (notify && wsReady) {
          sendSignal({
            type: "VIEWER_STOP",
            nickname,
            connectionId: session.connectionId,
          });
        }

        try {
          session.pc.ontrack = null;
          session.pc.onicecandidate = null;
          session.pc.onconnectionstatechange = null;
          session.pc.close();
        } catch (error) {
          console.warn("Не удалось закрыть peer", error);
        }

        if (session.stream) {
          session.stream.getTracks().forEach((track) => track.stop());
        }

        if (displayedNickname === nickname) {
          setDisplay(null, null);
        }
      }

      function cleanupAllSessions({ notify = false } = {}) {
        for (const nickname of Array.from(sessions.keys())) {
          cleanupSession(nickname, { notify });
        }
      }

      function restartSession(nickname) {
        if (!knownPublishers.has(nickname)) {
          cleanupSession(nickname, { notify: true });
          return;
        }

        const hadSession = sessions.has(nickname);
        cleanupSession(nickname, { notify: true });

        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (hadSession) {
          Promise.resolve().then(() => startSession(nickname));
        }
      }

      async function startSession(nickname) {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (!knownPublishers.has(nickname)) {
          return;
        }

        if (sessions.has(nickname)) {
          return;
        }

        const connectionId = createConnectionId();
        const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        const session = { nickname, connectionId, pc, stream: null };
        sessions.set(nickname, session);

        pc.ontrack = (event) => {
          const [stream] = event.streams || [];
          if (!stream) {
            return;
          }

          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            stream.getTracks().forEach((track) => track.stop());
            return;
          }

          current.stream = stream;
          if (desiredFocus === nickname) {
            setDisplay(stream, nickname);
          }
        };

        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            return;
          }
          sendSignal({
            type: "VIEWER_ICE",
            nickname,
            connectionId,
            candidate: event.candidate,
          });
        };

        pc.onconnectionstatechange = () => {
          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            return;
          }

          if (pc.connectionState === "connected") {
            return;
          }

          if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
            restartSession(nickname);
          } else if (pc.connectionState === "closed") {
            cleanupSession(nickname, { notify: false });
          }
        };

        try {
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);

          sendSignal({
            type: "VIEWER_OFFER",
            nickname,
            connectionId,
            sdp: pc.localDescription,
          });
        } catch (error) {
          console.error("Не удалось начать WebRTC-сессию", error);
          restartSession(nickname);
        }
      }

      function syncSessions() {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        for (const nickname of knownPublishers) {
          if (!sessions.has(nickname)) {
            startSession(nickname);
          }
        }

        for (const nickname of Array.from(sessions.keys())) {
          if (!knownPublishers.has(nickname)) {
            cleanupSession(nickname, { notify: true });
          }
        }

        updateDisplay();
      }

      function handlePublisherAnswer(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        session.pc.setRemoteDescription(payload.sdp).catch((error) => {
          console.error("Не удалось применить answer", error);
          restartSession(nickname);
        });
      }

      async function handlePublisherCandidate(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        try {
          await session.pc.addIceCandidate(payload.candidate || null);
        } catch (error) {
          console.error("Ошибка ICE", error);
        }
      }

      function handleStreamUnavailable(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        restartSession(nickname);
      }

      function handleActivePublishers(list) {
        knownPublishers.clear();

        if (Array.isArray(list)) {
          for (const name of list) {
            const normalized = normalizeNickname(name);
            if (normalized) {
              knownPublishers.add(normalized);
            }
          }
        }

        if (desiredFocus && !knownPublishers.has(desiredFocus)) {
          desiredFocus = null;
        }

        syncSessions();
      }

      function handleFocusUpdate(name) {
        const normalized = normalizeNickname(name);
        if (normalized === desiredFocus) {
          return;
        }

        desiredFocus = normalized;
        updateDisplay();
      }

      function handleMessage(event) {
        let payload;

        try {
          payload = JSON.parse(event.data);
        } catch (error) {
          return;
        }

        switch (payload.type) {
          case "WELCOME":
            handleActivePublishers(payload.publishers);
            handleFocusUpdate(payload.currentFocus);
            break;
          case "STATE_UPDATE":
            handleFocusUpdate(payload.currentFocus);
            break;
          case "VIEWER_REGISTERED":
            viewerRegistered = true;
            syncSessions();
            break;
          case "ACTIVE_PUBLISHERS":
            handleActivePublishers(payload.publishers);
            break;
          case "SIGNAL_PUBLISHER_ANSWER":
            handlePublisherAnswer(payload);
            break;
          case "SIGNAL_PUBLISHER_CANDIDATE":
            handlePublisherCandidate(payload);
            break;
          case "STREAM_UNAVAILABLE":
          case "STREAM_ENDED":
            handleStreamUnavailable(payload);
            break;
          default:
            break;
        }
      }

      function connectWebSocket() {
        if (ws) {
          try {
            ws.close();
          } catch (error) {
            // ignore
          }
        }

        ws = new WebSocket(wsUrl);

        ws.addEventListener("open", () => {
          wsReady = true;
          viewerRegistered = false;
          sendSignal({ type: "HELLO", role: "viewer" });
          syncSessions();
        });

        ws.addEventListener("message", handleMessage);

        ws.addEventListener("close", () => {
          wsReady = false;
          viewerRegistered = false;
          knownPublishers.clear();
          cleanupAllSessions({ notify: false });
          setDisplay(null, null);

          if (reconnectTimer) {
            return;
          }
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connectWebSocket();
          }, 2000);
        });

        ws.addEventListener("error", () => {
          ws.close();
        });
      }

      connectWebSocket();

      window.addEventListener("beforeunload", () => {
        cleanupAllSessions({ notify: true });
      });
    });
  </script>
</body>
</html>
