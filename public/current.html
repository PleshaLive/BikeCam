<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Current Focus Feed</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
    }

    #feed {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      background: transparent;
      transition: opacity 120ms ease;
      opacity: 0;
      visibility: hidden;
    }
  </style>
</head>
<body>
  <div class="stage">
    <video id="feed" autoplay playsinline muted></video>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const video = document.getElementById("feed");
      const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

      let ws;
      let wsReady = false;
      let desiredFocus = null;
      let reconnectTimer = null;
      let connectionCounter = 0;
      let activePeer = null;

      function createConnectionId() {
        connectionCounter += 1;
        return `viewer-${Date.now()}-${connectionCounter}`;
      }

      function setVideoStream(stream) {
        const current = video.srcObject;
        if (current && current !== stream) {
          current.getTracks().forEach((track) => track.stop());
        }
        if (stream) {
          video.srcObject = stream;
          video.style.opacity = "1";
          video.style.visibility = "visible";
        } else {
          video.srcObject = null;
          video.style.opacity = "0";
          video.style.visibility = "hidden";
        }
      }

      function sendSignal(payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(payload));
        }
      }

      function cleanupPeer({ notify = true } = {}) {
        if (!activePeer) {
          return;
        }

        const { nickname, connectionId, pc } = activePeer;
        activePeer = null;

        if (notify && wsReady) {
          sendSignal({ type: "VIEWER_STOP", nickname, connectionId });
        }

        try {
          pc.onicecandidate = null;
          pc.ontrack = null;
          pc.onconnectionstatechange = null;
          pc.close();
        } catch (error) {
          console.warn("Не удалось закрыть RTCPeerConnection", error);
        }

        setVideoStream(null);
      }

      async function startPeer(nickname) {
        if (!wsReady) {
          return;
        }

        const connectionId = createConnectionId();
        const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

        activePeer = { nickname, connectionId, pc };

        pc.ontrack = (event) => {
          const [stream] = event.streams;
          if (stream) {
            setVideoStream(stream);
          }
        };

        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            return;
          }
          sendSignal({
            type: "VIEWER_ICE",
            nickname,
            connectionId,
            candidate: event.candidate,
          });
        };

        pc.onconnectionstatechange = () => {
          if (!activePeer || activePeer.connectionId !== connectionId) {
            return;
          }

          if (pc.connectionState === "connected") {
            return;
          }

          if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
            cleanupPeer({ notify: true });
            setTimeout(maybeStartPeer, 1500);
          }
        };

        try {
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);

          sendSignal({
            type: "VIEWER_OFFER",
            nickname,
            connectionId,
            sdp: pc.localDescription,
          });
        } catch (error) {
          console.error("Не удалось начать WebRTC-сессию", error);
          cleanupPeer({ notify: true });
        }
      }

      function maybeStartPeer() {
        if (!wsReady || !desiredFocus) {
          return;
        }

        if (activePeer && activePeer.nickname === desiredFocus) {
          return;
        }

        if (activePeer) {
          cleanupPeer({ notify: true });
        }

        startPeer(desiredFocus);
      }

      function handlePublisherAnswer(payload) {
        if (!activePeer) {
          return;
        }

        if (activePeer.connectionId !== payload.connectionId || activePeer.nickname !== payload.nickname) {
          return;
        }

        activePeer.pc.setRemoteDescription(payload.sdp).catch((error) => {
          console.error("Не удалось применить answer от издателя", error);
          cleanupPeer({ notify: true });
        });
      }

      async function handlePublisherCandidate(payload) {
        if (!activePeer) {
          return;
        }

        if (activePeer.connectionId !== payload.connectionId || activePeer.nickname !== payload.nickname) {
          return;
        }

        try {
          await activePeer.pc.addIceCandidate(payload.candidate || null);
        } catch (error) {
          console.error("Ошибка ICE от издателя", error);
        }
      }

      function handleStreamUnavailable(payload) {
        if (activePeer && activePeer.connectionId === payload.connectionId) {
          cleanupPeer({ notify: false });
        }

        if (payload.nickname === desiredFocus) {
          setVideoStream(null);
          setTimeout(maybeStartPeer, 2000);
        }
      }

      function handleMessage(event) {
        let payload;

        try {
          payload = JSON.parse(event.data);
        } catch (error) {
          return;
        }

        switch (payload.type) {
          case "WELCOME":
          case "STATE_UPDATE": {
            const focusName = typeof payload.currentFocus === "string" && payload.currentFocus.trim()
              ? payload.currentFocus.trim()
              : null;

            if (focusName !== desiredFocus) {
              desiredFocus = focusName;
              if (!desiredFocus) {
                cleanupPeer({ notify: true });
                setVideoStream(null);
              }
            }
            maybeStartPeer();
            break;
          }
          case "SIGNAL_PUBLISHER_ANSWER":
            handlePublisherAnswer(payload);
            break;
          case "SIGNAL_PUBLISHER_CANDIDATE":
            handlePublisherCandidate(payload);
            break;
          case "STREAM_UNAVAILABLE":
          case "STREAM_ENDED":
            handleStreamUnavailable(payload);
            break;
          default:
            break;
        }
      }

      function connectWebSocket() {
        ws = new WebSocket(wsUrl);

        ws.addEventListener("open", () => {
          wsReady = true;
          sendSignal({ type: "HELLO", role: "viewer" });
          maybeStartPeer();
        });

        ws.addEventListener("message", handleMessage);

        ws.addEventListener("close", () => {
          wsReady = false;
          cleanupPeer({ notify: false });
          if (reconnectTimer) {
            return;
          }
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connectWebSocket();
          }, 2000);
        });

        ws.addEventListener("error", () => {
          ws.close();
        });
      }

      connectWebSocket();

      window.addEventListener("beforeunload", () => {
        cleanupPeer({ notify: true });
      });
    });
  </script>
</body>
</html>
