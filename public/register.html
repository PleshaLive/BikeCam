<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxy Battle | Camera Link</title>
  <style>
    :root {
      color-scheme: dark;
      --brand-primary: #221c3b;
      --brand-accent: #2f2658;
      --brand-pop: #6d5ad0;
      --brand-soft: #3a305f;
      --surface: rgba(24, 18, 48, 0.92);
      --surface-strong: rgba(29, 23, 57, 0.96);
      --border: rgba(109, 90, 208, 0.2);
      --text-main: #f5f2ff;
      --text-muted: rgba(245, 242, 255, 0.72);
      --success: #5bd997;
      --success-strong: #2eaf73;
      --success-soft: rgba(91, 217, 151, 0.28);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 40px 16px;
      font-family: "Montserrat", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text-main);
      background: radial-gradient(circle at 20% 20%, rgba(109, 90, 208, 0.25), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(58, 48, 95, 0.55), transparent 50%),
        linear-gradient(135deg, #120d25 0%, var(--brand-primary) 45%, #1b1532 100%);
    }

    .card {
      position: relative;
      width: 100%;
      max-width: 520px;
      padding: 32px;
      border-radius: 24px;
      background: var(--surface);
      border: 1px solid var(--border);
      box-shadow: 0 45px 90px rgba(11, 9, 22, 0.55), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(12px);
    }

    .card.connected {
      border-color: rgba(91, 217, 151, 0.75);
      box-shadow: 0 55px 110px rgba(20, 40, 32, 0.65), inset 0 0 0 1px rgba(91, 217, 151, 0.35);
    }

    .brand-chip {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 18px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.34em;
      font-size: 0.78rem;
      font-weight: 700;
      color: var(--text-main);
      background: rgba(109, 90, 208, 0.16);
      border: 1px solid rgba(109, 90, 208, 0.35);
      margin-bottom: 18px;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 1.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .subtitle {
      margin: 0 0 28px;
      font-size: 0.95rem;
      color: var(--text-muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    label {
      display: block;
      margin-bottom: 10px;
      font-size: 0.82rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    select,
    button {
      width: 100%;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      margin-bottom: 16px;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.06em;
    }

    select {
      background: var(--surface-strong);
      color: var(--text-main);
    }

    select:disabled {
      opacity: 0.55;
    }

    button {
      background: linear-gradient(145deg, var(--brand-pop), #4e3ca0);
      color: var(--text-main);
      cursor: pointer;
      border: none;
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      box-shadow: 0 22px 44px rgba(15, 12, 36, 0.55);
    }

    button:hover:not([disabled]) {
      transform: translateY(-2px);
      box-shadow: 0 26px 54px rgba(15, 12, 36, 0.65);
    }

    button:active:not([disabled]) {
      transform: translateY(0);
    }

    button.connected {
      background: linear-gradient(145deg, var(--success), var(--success-strong));
      box-shadow: 0 26px 52px rgba(25, 63, 44, 0.6);
    }

    button.secondary {
      background: transparent;
      border: 1px solid rgba(109, 90, 208, 0.32);
      box-shadow: none;
    }

    button.secondary:hover:not([disabled]) {
      background: rgba(109, 90, 208, 0.12);
    }

    #startCameraBtn {
      display: none;
      margin-top: -4px;
    }

    #applySelectionBtn[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    video {
      width: 100%;
      border-radius: 16px;
      background: rgba(12, 9, 28, 0.88);
      margin-bottom: 20px;
      border: 1px solid rgba(109, 90, 208, 0.24);
      box-shadow: inset 0 0 65px rgba(11, 9, 30, 0.65);
    }

    .hint {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 18px;
      letter-spacing: 0.04em;
    }

    .status {
      font-size: 0.85rem;
      color: var(--text-muted);
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
  </style>
  <script src="js/webrtc-support.js"></script>
</head>
<body>
  <div class="card">
    <span class="brand-chip">Galaxy Battle</span>
    <h1>Camera Link Console</h1>
    <p class="subtitle">Choose your nickname and camera to go live.</p>
    <label for="nicknameSelect">Select your nickname</label>
    <select id="nicknameSelect">
  <option value="">- choose nickname -</option>
    </select>
    <button id="refreshBtn" type="button" class="secondary">Refresh player list</button>

    <label for="cameraSelect">Select your camera</label>
    <select id="cameraSelect">
  <option value="">- default camera -</option>
    </select>
    <button id="cameraRefreshBtn" type="button" class="secondary">Refresh camera list</button>
  <button id="applySelectionBtn" type="button" disabled>Apply Selection</button>
    <button id="startCameraBtn" type="button">Enable camera</button>

    <video id="camPreview" autoplay playsinline muted></video>
  <p class="hint">If you don't see yourself in the list, join the game server.</p>
  <p class="status" id="status">Requesting camera access...</p>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const nicknameSelect = document.getElementById("nicknameSelect");
      const refreshBtn = document.getElementById("refreshBtn");
      const cameraSelect = document.getElementById("cameraSelect");
      const cameraRefreshBtn = document.getElementById("cameraRefreshBtn");
      const applySelectionBtn = document.getElementById("applySelectionBtn");
      const startCameraBtn = document.getElementById("startCameraBtn");
      const status = document.getElementById("status");
      const video = document.getElementById("camPreview");
      const card = document.querySelector(".card");

      const defaultIceServers = [{ urls: "stun:stun.l.google.com:19302" }];
      let resolvedConfig = { iceServers: defaultIceServers, fallback: {} };
      try {
        const config = await (window.WebRTC_SUPPORT?.getConfig?.() ?? Promise.resolve(resolvedConfig));
        if (config && typeof config === "object") {
          resolvedConfig = config;
        }
      } catch (error) {
        resolvedConfig = { iceServers: defaultIceServers, fallback: {} };
      }

      const ICE_SERVERS = Array.isArray(resolvedConfig.iceServers) && resolvedConfig.iceServers.length ? resolvedConfig.iceServers : defaultIceServers;
      const fallbackSettings = resolvedConfig.fallback && typeof resolvedConfig.fallback === "object" ? resolvedConfig.fallback : {};
      const fallbackIntervalMs = Math.max(200, Math.round(1000 / Math.max(1, fallbackSettings.maxFps || 5)));
      const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      const hasSecureContext = window.isSecureContext || location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";
      const hasWebRTC = window.WebRTC_SUPPORT?.hasWebRTCSupport?.() ?? typeof window.RTCPeerConnection === "function";

      const peers = new Map();
      const takenNicknames = new Set();
      const senderMonitors = new Map();

      const fallbackState = {
        timer: null,
        sending: false,
        canvas: null,
        context: null,
        lastSent: 0,
      };

      let bitrateMonitorTimer = null;
      const BITRATE_LEVELS = [400000, 800000, 1200000, 1800000, 2500000];

          let ws;
          let wsReady = false;
          let selectedNickname = "";
          let currentStream = null;
          let selectedCameraId = "";
          let pendingDeviceId = "";
          let autoStartAttempted = false;
          let lastAppliedNickname = "";
          let lastAppliedCameraId = "";
          let knownPlayers = [];
          let isConnected = false;

          function peerKey(viewerSocketId, connectionId) {
            return `${viewerSocketId}:${connectionId}`;
          }

          function mediaApisAvailable() {
            return (
              (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === "function") ||
              typeof navigator.getUserMedia === "function" ||
              typeof navigator.webkitGetUserMedia === "function" ||
              typeof navigator.mozGetUserMedia === "function"
            );
          }

          async function requestStream(constraints) {
            if (navigator.mediaDevices?.getUserMedia) {
              return navigator.mediaDevices.getUserMedia(constraints);
            }

            const legacy = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            if (legacy) {
              return new Promise((resolve, reject) => legacy.call(navigator, constraints, resolve, reject));
            }

            const error = new Error("MEDIA_NOT_SUPPORTED");
            error.code = "MEDIA_NOT_SUPPORTED";
            throw error;
          }

      function ensureFallbackCanvas(width, height) {
        const safeWidth = Math.max(1, Math.floor(width) || 1);
        const safeHeight = Math.max(1, Math.floor(height) || 1);

        if (!fallbackState.canvas) {
          fallbackState.canvas = document.createElement("canvas");
          fallbackState.context = fallbackState.canvas.getContext("2d", { alpha: false });
        }

        if (!fallbackState.context) {
          return null;
        }

        if (fallbackState.canvas.width !== safeWidth || fallbackState.canvas.height !== safeHeight) {
          fallbackState.canvas.width = safeWidth;
          fallbackState.canvas.height = safeHeight;
        }

        return fallbackState.context;
      }

      function canvasToBlob(canvas) {
        return new Promise((resolve, reject) => {
          canvas.toBlob(
            (blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error("Failed to create fallback frame"));
              }
            },
            "image/jpeg",
            0.7,
          );
        });
      }

      async function captureFallbackBlob() {
        if (!currentStream) {
          return null;
        }

        const [track] = currentStream.getVideoTracks().filter((item) => item.readyState === "live");
        const fallbackWidth = video.videoWidth || track?.getSettings?.().width || 1280;
        const fallbackHeight = video.videoHeight || track?.getSettings?.().height || 720;

        if (typeof ImageCapture === "function" && track) {
          try {
            const capture = new ImageCapture(track);
            const bitmap = await capture.grabFrame();
            const context = ensureFallbackCanvas(bitmap.width || fallbackWidth, bitmap.height || fallbackHeight);
            if (!context) {
              return null;
            }
            context.drawImage(bitmap, 0, 0, context.canvas.width, context.canvas.height);
            if (typeof bitmap.close === "function") {
              bitmap.close();
            }
            return canvasToBlob(context.canvas);
          } catch (error) {
            // fall back to drawing from the preview element
          }
        }

        const context = ensureFallbackCanvas(fallbackWidth, fallbackHeight);
        if (!context) {
          return null;
        }

        try {
          context.drawImage(video, 0, 0, context.canvas.width, context.canvas.height);
        } catch (error) {
          return null;
        }

        return canvasToBlob(context.canvas);
      }

      function bytesToBase64(bytes) {
        let binary = "";
        const length = bytes.length;
        for (let index = 0; index < length; index += 1) {
          binary += String.fromCharCode(bytes[index]);
        }
        return window.btoa(binary);
      }

      async function sendFallbackFrame() {
        if (!fallbackSettings.mjpeg || !lastAppliedNickname || !currentStream) {
          return;
        }

        if (fallbackState.sending) {
          return;
        }

        const now = Date.now();
        if (now - fallbackState.lastSent < fallbackIntervalMs - 20) {
          return;
        }

        fallbackState.sending = true;
        try {
          const blob = await captureFallbackBlob();
          if (!blob) {
            return;
          }

          const arrayBuffer = await blob.arrayBuffer();
          const base64 = bytesToBase64(new Uint8Array(arrayBuffer));

          await fetch("/api/fallback/frame", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              nickname: lastAppliedNickname,
              frame: base64,
              mimeType: blob.type || "image/jpeg",
            }),
            keepalive: true,
          });
        } catch (error) {
          // ignore fallback transport errors
        } finally {
          fallbackState.sending = false;
          fallbackState.lastSent = Date.now();
        }
      }

      function startFallbackFrames() {
        if (!fallbackSettings.mjpeg || fallbackState.timer) {
          return;
        }

        fallbackState.lastSent = 0;
        fallbackState.timer = setInterval(() => {
          sendFallbackFrame().catch(() => {});
        }, fallbackIntervalMs);
        sendFallbackFrame().catch(() => {});
      }

      function stopFallbackFrames() {
        if (fallbackState.timer) {
          clearInterval(fallbackState.timer);
          fallbackState.timer = null;
        }
        fallbackState.sending = false;
      }

      function applySenderEncoding(sender, bitrate) {
        if (!sender) {
          return;
        }

        try {
          const parameters = sender.getParameters();
          if (!Array.isArray(parameters.encodings) || !parameters.encodings.length) {
            parameters.encodings = [{}];
          }
          parameters.degradationPreference = "maintain-framerate";
          parameters.encodings[0].maxBitrate = bitrate;
          parameters.encodings[0].maxFramerate = 30;
          parameters.encodings[0].scaleResolutionDownBy = parameters.encodings[0].scaleResolutionDownBy || 1;
          sender.setParameters(parameters).catch(() => {});
        } catch (error) {
          console.warn("Failed to adjust encoder parameters", error);
        }
      }

      function registerSenderMonitor(key, pc) {
        if (!pc) {
          return;
        }

        const sender = pc
          .getSenders()
          .find((item) => item && item.track && item.track.kind === "video" && item.track.readyState === "live");

        if (!sender) {
          return;
        }

        const state = senderMonitors.get(key) || {
          sender,
          levelIndex: BITRATE_LEVELS.length - 1,
          lastBytes: 0,
          lastTimestamp: 0,
          lastAdjust: 0,
        };

        state.sender = sender;
        senderMonitors.set(key, state);
        applySenderEncoding(sender, BITRATE_LEVELS[state.levelIndex]);
        startBitrateMonitor();
      }

      function removeSenderMonitor(key) {
        senderMonitors.delete(key);
        if (senderMonitors.size === 0 && bitrateMonitorTimer) {
          clearInterval(bitrateMonitorTimer);
          bitrateMonitorTimer = null;
        }
      }

      function startBitrateMonitor() {
        if (bitrateMonitorTimer || senderMonitors.size === 0) {
          return;
        }

        bitrateMonitorTimer = setInterval(() => {
          evaluateSenderMonitors().catch(() => {});
        }, 4000);
      }

      async function evaluateSenderMonitors() {
        if (senderMonitors.size === 0) {
          return;
        }

        const tasks = [];
        const now = Date.now();

        for (const [key, state] of senderMonitors.entries()) {
          if (!state.sender?.track || state.sender.track.readyState !== "live") {
            removeSenderMonitor(key);
            continue;
          }

          tasks.push(
            state.sender
              .getStats()
              .then((stats) => {
                let outbound = null;
                stats.forEach((report) => {
                  if (report.type === "outbound-rtp" && report.kind === "video" && !report.isRemote) {
                    outbound = report;
                  }
                });

                if (!outbound || !outbound.bytesSent) {
                  return;
                }

                if (state.lastTimestamp && outbound.timestamp > state.lastTimestamp) {
                  const deltaBytes = outbound.bytesSent - state.lastBytes;
                  const deltaMs = outbound.timestamp - state.lastTimestamp;
                  const bitrate = deltaMs > 0 ? (deltaBytes * 8 * 1000) / deltaMs : 0;
                  const packetsSent = outbound.packetsSent || 0;
                  const packetsLost = outbound.packetsLost || 0;
                  const totalPackets = packetsSent + packetsLost;
                  const lossRatio = totalPackets > 0 ? packetsLost / totalPackets : 0;

                  let nextIndex = state.levelIndex;

                  if (lossRatio > 0.08 || bitrate < BITRATE_LEVELS[state.levelIndex] * 0.6) {
                    nextIndex = Math.max(0, state.levelIndex - 1);
                  } else if (lossRatio < 0.02 && bitrate > BITRATE_LEVELS[state.levelIndex] * 0.85) {
                    nextIndex = Math.min(BITRATE_LEVELS.length - 1, state.levelIndex + 1);
                  }

                  if (nextIndex !== state.levelIndex && now - state.lastAdjust > 5000) {
                    state.levelIndex = nextIndex;
                    state.lastAdjust = now;
                    applySenderEncoding(state.sender, BITRATE_LEVELS[state.levelIndex]);
                  }
                }

                state.lastBytes = outbound.bytesSent;
                state.lastTimestamp = outbound.timestamp;
              })
              .catch(() => {}),
          );
        }

        await Promise.allSettled(tasks);

        if (senderMonitors.size === 0 && bitrateMonitorTimer) {
          clearInterval(bitrateMonitorTimer);
          bitrateMonitorTimer = null;
        }
      }

          async function loadPlayers() {
            try {
              const response = await fetch("/players", { cache: "no-store" });
              if (!response.ok) {
                throw new Error("Failed to load players");
              }

              const payload = await response.json();
              populateSelect(payload.players || []);
              updateApplyButtonState();
            } catch (error) {
              status.textContent = "Unable to load players. Try refreshing later.";
            }
          }

          function populateSelect(players) {
            if (Array.isArray(players)) {
              knownPlayers = [...players];
            }

            const previousValue = nicknameSelect.value;
            const desiredValue = selectedNickname || previousValue;

            nicknameSelect.innerHTML = "";

            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "- choose nickname -";
            nicknameSelect.appendChild(placeholder);

            let restoredValue = "";

            for (const name of knownPlayers) {
              if (typeof name !== "string" || !name.trim()) {
                continue;
              }

              const option = document.createElement("option");
              option.value = name;

              const takenByOther = takenNicknames.has(name) && name !== lastAppliedNickname;
              if (takenByOther) {
                option.disabled = true;
                option.textContent = `${name} - taken`;
              } else {
                option.textContent = name;
              }

              nicknameSelect.appendChild(option);

              if (!takenByOther && name === desiredValue) {
                restoredValue = name;
              }
            }

            if (restoredValue) {
              nicknameSelect.value = restoredValue;
              selectedNickname = restoredValue;
            } else {
              nicknameSelect.value = "";
              if (selectedNickname && takenNicknames.has(selectedNickname) && selectedNickname !== lastAppliedNickname) {
                selectedNickname = "";
                status.textContent = "That nickname is already taken. Please pick another.";
              }
            }

            updateApplyButtonState();
          }

          function sendSignal(payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(payload));
            }
          }

          function ensurePublisherRegistration() {
            if (!wsReady || !selectedNickname || !currentStream) {
              return;
            }

            if (selectedNickname !== lastAppliedNickname) {
              return;
            }
            sendSignal({ type: "HELLO", role: "publisher", nickname: selectedNickname });
          }

          function cleanupPeer(key, notifyServer = true) {
            const session = peers.get(key);
            if (!session) {
              return;
            }

            peers.delete(key);
            removeSenderMonitor(key);

            try {
              session.pc.onicecandidate = null;
              session.pc.onconnectionstatechange = null;
              session.pc.close();
            } catch (error) {
              console.warn("Failed to close peer cleanly", error);
            }

            if (notifyServer) {
              sendSignal({
                type: "PUBLISHER_PEER_CLOSED",
                viewerSocketId: session.viewerSocketId,
                connectionId: session.connectionId,
                nickname: session.nickname,
              });
            }
          }

          function updateApplyButtonState() {
            const nicknameReady = Boolean(selectedNickname);
            const cameraReady = Boolean(selectedCameraId || currentStream);
            const sameSelection =
              nicknameReady &&
              cameraReady &&
              selectedNickname === lastAppliedNickname &&
              selectedCameraId === lastAppliedCameraId;

            applySelectionBtn.disabled = !(nicknameReady && cameraReady);

            if (!sameSelection && isConnected) {
              setConnected(false);
            }

            if (!nicknameReady || !cameraReady) {
              applySelectionBtn.textContent = "Apply Selection";
              return;
            }

            if (isConnected && sameSelection) {
              applySelectionBtn.textContent = "Connected";
            } else {
              applySelectionBtn.textContent = "Apply Selection";
            }
          }

          function setConnected(state) {
            if (isConnected === state) {
              return;
            }
            isConnected = state;
            if (card) {
              card.classList.toggle("connected", state);
            }
            applySelectionBtn.classList.toggle("connected", state);

            if (state) {
              startFallbackFrames();
            } else {
              stopFallbackFrames();
            }
          }

          function updateTakenNicknames(list) {
            takenNicknames.clear();

            if (Array.isArray(list)) {
              for (const name of list) {
                if (typeof name === "string" && name.trim()) {
                  takenNicknames.add(name.trim());
                }
              }
            }

            populateSelect();

            if (isConnected && lastAppliedNickname && !takenNicknames.has(lastAppliedNickname)) {
              setConnected(false);
              if (selectedNickname === lastAppliedNickname) {
                status.textContent = "You were disconnected. Apply selection again.";
              }
              updateApplyButtonState();
            }
          }

          function closeAllPeers() {
            for (const key of Array.from(peers.keys())) {
              cleanupPeer(key, true);
            }
          }

          function buildPublisherPeer({ viewerSocketId, connectionId, nickname }) {
            if (!hasWebRTC) {
              return null;
            }
            const key = peerKey(viewerSocketId, connectionId);
            const pc = new RTCPeerConnection({
              iceServers: ICE_SERVERS,
              iceTransportPolicy: "relay",
            });
            peers.set(key, { pc, viewerSocketId, connectionId, nickname });

            if (currentStream) {
              currentStream.getTracks().forEach((track) => pc.addTrack(track, currentStream));
            }

            registerSenderMonitor(key, pc);

            pc.onicecandidate = (event) => {
              if (!event.candidate) {
                return;
              }
              sendSignal({
                type: "PUBLISHER_ICE",
                viewerSocketId,
                connectionId,
                candidate: event.candidate,
              });
            };

            pc.onconnectionstatechange = () => {
              if (pc.connectionState === "failed" || pc.connectionState === "disconnected" || pc.connectionState === "closed") {
                cleanupPeer(key, pc.connectionState !== "closed");
              }
            };

            return pc;
          }

          async function handleViewerOffer(payload) {
            if (!currentStream) {
              status.textContent = "Camera preview is offline. Start the feed first.";
              return;
            }

            const { viewerSocketId, connectionId, nickname, sdp } = payload;
            const key = peerKey(viewerSocketId, connectionId);

            if (peers.has(key)) {
              cleanupPeer(key, true);
            }

            const pc = buildPublisherPeer({ viewerSocketId, connectionId, nickname });
            if (!pc) {
              status.textContent = "WebRTC is unavailable. MJPEG fallback is running.";
              return;
            }

            try {
              await pc.setRemoteDescription(sdp);
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);

              sendSignal({
                type: "PUBLISHER_ANSWER",
                viewerSocketId,
                connectionId,
                sdp: pc.localDescription,
              });
            } catch (error) {
              console.error("Failed to process viewer offer", error);
              status.textContent = "WebRTC negotiation failed. Refresh the page and try again.";
              cleanupPeer(key, true);
            }
          }

          async function handleViewerCandidate(payload) {
            const { viewerSocketId, connectionId, candidate } = payload;
            const key = peerKey(viewerSocketId, connectionId);
            const session = peers.get(key);
            if (!session) {
              return;
            }

            try {
              await session.pc.addIceCandidate(candidate || null);
            } catch (error) {
              console.error("Failed to apply ICE candidate", error);
            }
          }

          function handleViewerDisconnected(payload) {
            const { viewerSocketId, connectionId } = payload;
            cleanupPeer(peerKey(viewerSocketId, connectionId), false);
          }

          function startWebSocket() {
            ws = new WebSocket(wsUrl);

            ws.addEventListener("open", () => {
              wsReady = true;
              status.textContent = "Connected to the server. Pick your nickname and enable the camera.";
              ensurePublisherRegistration();
            });

            ws.addEventListener("message", (event) => {
              let payload;
              try {
                payload = JSON.parse(event.data);
              } catch (error) {
                return;
              }

              switch (payload.type) {
                case "SIGNAL_VIEWER_OFFER":
                  handleViewerOffer(payload);
                  break;
                case "SIGNAL_VIEWER_CANDIDATE":
                  handleViewerCandidate(payload);
                  break;
                case "VIEWER_DISCONNECTED":
                  handleViewerDisconnected(payload);
                  break;
                case "WELCOME":
                  if (Array.isArray(payload.publishers)) {
                    updateTakenNicknames(payload.publishers);
                  }
                  break;
                case "ACTIVE_PUBLISHERS":
                  updateTakenNicknames(payload.publishers);
                  break;
                case "PUBLISHER_REGISTERED": {
                  const nickname = payload.nickname;
                  if (nickname === lastAppliedNickname) {
                    status.textContent = `Camera ${nickname} is live for viewers.`;
                    setConnected(true);
                    updateApplyButtonState();
                  }
                  if (nickname) {
                    takenNicknames.add(nickname);
                    populateSelect();
                  }
                  break;
                }
                case "ERROR":
                  status.textContent = payload.message || "Server error.";
                  if ((payload.message || "").toLowerCase().includes("already in use")) {
                    setConnected(false);
                    updateApplyButtonState();
                  }
                  break;
                default:
                  break;
              }
            });

            ws.addEventListener("close", () => {
              wsReady = false;
              closeAllPeers();
              setConnected(false);
              status.textContent = "Connection closed. Reconnecting...";
              updateApplyButtonState();
              setTimeout(startWebSocket, 2000);
            });

            ws.addEventListener("error", () => {
              status.textContent = "Connection error. Refresh the page if it persists.";
            });
          }

          function stopCurrentStream() {
            closeAllPeers();
            if (currentStream) {
              currentStream.getTracks().forEach((track) => track.stop());
              currentStream = null;
            }
            video.srcObject = null;
            setConnected(false);
            updateApplyButtonState();
          }

          function showStartButton(message) {
            if (message) {
              status.textContent = message;
            }
            startCameraBtn.style.display = "block";
            startCameraBtn.disabled = false;
          }

          function hideStartButton() {
            startCameraBtn.style.display = "none";
          }

          function setCameraControlsEnabled(enabled) {
            cameraSelect.disabled = !enabled;
            cameraRefreshBtn.disabled = !enabled;
          }

          async function loadCameraDevices(preferredId = "") {
            if (!navigator.mediaDevices?.enumerateDevices) {
              return;
            }

            try {
              const devices = await navigator.mediaDevices.enumerateDevices();
              const videoInputs = devices.filter((device) => device.kind === "videoinput");

              const currentValue = preferredId || pendingDeviceId || selectedCameraId || cameraSelect.value;

              cameraSelect.innerHTML = "";
              if (videoInputs.length === 0) {
                const option = document.createElement("option");
                option.value = "";
                option.textContent = "No camera found";
                cameraSelect.appendChild(option);
                cameraSelect.disabled = true;
                updateApplyButtonState();
                return;
              }

              cameraSelect.disabled = false;

              videoInputs.forEach((device, index) => {
                const option = document.createElement("option");
                option.value = device.deviceId;
                option.textContent = device.label || `Camera ${index + 1}`;
                cameraSelect.appendChild(option);
              });

              const matched = videoInputs.some((device) => device.deviceId === currentValue);
              if (matched) {
                cameraSelect.value = currentValue;
              } else {
                cameraSelect.selectedIndex = 0;
                selectedCameraId = cameraSelect.value;
              }

              updateApplyButtonState();
            } catch (error) {
              console.error("Failed to enumerate cameras", error);
              updateApplyButtonState();
            }
          }

          async function startStream(deviceId, allowFallback = true) {
            autoStartAttempted = true;
            stopCurrentStream();

            try {
              const constraints = {
                video: {
                  width: { ideal: 1280 },
                  height: { ideal: 720 },
                  frameRate: { ideal: 30 },
                },
                audio: false,
              };

              if (deviceId) {
                constraints.video.deviceId = { exact: deviceId };
              } else {
                constraints.video.facingMode = { ideal: "user" };
              }

              const stream = await requestStream(constraints);
              currentStream = stream;
              video.srcObject = stream;

              const activeTrack = stream.getVideoTracks()[0];
              if (activeTrack?.applyConstraints) {
                try {
                  await activeTrack.applyConstraints({
                    width: { ideal: 1280, max: 1280 },
                    height: { ideal: 720, max: 720 },
                    frameRate: { ideal: 30, max: 30 },
                  });
                } catch (applyError) {
                  console.warn("Failed to apply advanced camera constraints", applyError);
                }
              }

              const appliedDeviceId = activeTrack?.getSettings?.().deviceId || deviceId || "";
              selectedCameraId = appliedDeviceId;
              pendingDeviceId = "";
              await loadCameraDevices(appliedDeviceId);
              status.textContent = "Camera feed is ready. Apply your selection to go live.";
              hideStartButton();
              setCameraControlsEnabled(true);
              ensurePublisherRegistration();
              updateApplyButtonState();
            } catch (error) {
              console.error("getUserMedia error", error);
              stopCurrentStream();
              setCameraControlsEnabled(true);

              const errorName = error?.name || "";
              const errorMessage = (error?.message || "").toLowerCase();

              if (error?.code === "MEDIA_NOT_SUPPORTED") {
                status.textContent = "This browser does not support camera APIs. Switch to a modern browser or HTTPS.";
                showStartButton();
                updateApplyButtonState();
                return;
              }

              if (!hasSecureContext) {
                status.textContent = "Camera access requires HTTPS or launching from localhost.";
                showStartButton();
                updateApplyButtonState();
                return;
              }

              if (allowFallback && deviceId) {
                pendingDeviceId = "";
                status.textContent = "Selected camera failed to start. Falling back to the default device.";
                setTimeout(() => startStream(undefined, false), 200);
                showStartButton();
                updateApplyButtonState();
                return;
              }

              if (errorName === "NotAllowedError" || errorName === "SecurityError" || errorMessage.includes("gesture")) {
                showStartButton("Click \"Enable camera\" and grant permission to the browser.");
              } else if (errorName === "NotFoundError") {
                status.textContent = "No camera detected. Plug in a device and press \"Enable camera\".";
                showStartButton();
              } else if (errorName === "AbortError") {
                status.textContent = "Camera failed to start. Try again.";
                showStartButton();
              } else if (errorName === "OverconstrainedError" || errorMessage.includes("start video source") || errorMessage.includes("could not start")) {
                status.textContent = "Camera cannot start with the current constraints. Choose another device.";
                showStartButton();
              } else {
                status.textContent = "Camera error: " + (error?.message || "Unknown error");
                showStartButton();
              }
              updateApplyButtonState();
            }
          }

          nicknameSelect.addEventListener("change", () => {
            selectedNickname = nicknameSelect.value;
            if (!selectedNickname) {
              status.textContent = "Choose your nickname and camera, then press \"Apply Selection\".";
            } else if (selectedNickname !== lastAppliedNickname) {
              status.textContent = `Selected ${selectedNickname}. Don't forget to press \"Apply Selection\".`;
            }
            if (selectedNickname !== lastAppliedNickname) {
              setConnected(false);
            }
            updateApplyButtonState();
          });

          refreshBtn.addEventListener("click", () => {
            loadPlayers();
          });

          cameraSelect.addEventListener("change", () => {
            const deviceId = cameraSelect.value;
            pendingDeviceId = deviceId || "";
            if (currentStream && deviceId && deviceId !== selectedCameraId) {
              startStream(deviceId);
            }
            if (!currentStream) {
              selectedCameraId = pendingDeviceId;
            }
            if (selectedNickname && (selectedNickname !== lastAppliedNickname || (deviceId || "") !== lastAppliedCameraId)) {
              status.textContent = "Settings changed. Press \"Apply Selection\" to confirm.";
            }
            if ((deviceId || "") !== lastAppliedCameraId) {
              setConnected(false);
            }
            updateApplyButtonState();
          });

          cameraRefreshBtn.addEventListener("click", () => {
            loadCameraDevices();
          });

          applySelectionBtn.addEventListener("click", () => {
            if (applySelectionBtn.disabled) {
              return;
            }

            if (!selectedNickname) {
              status.textContent = "Select a nickname before applying settings.";
              return;
            }

            if (!selectedCameraId && pendingDeviceId) {
              selectedCameraId = pendingDeviceId;
            }
            if (!selectedCameraId) {
              selectedCameraId = cameraSelect.value || "";
            }

            const previousNickname = lastAppliedNickname;
            const previousCameraId = lastAppliedCameraId;
            lastAppliedNickname = selectedNickname;
            lastAppliedCameraId = selectedCameraId;

            if (previousNickname !== lastAppliedNickname || previousCameraId !== lastAppliedCameraId) {
              setConnected(false);
            }

            ensurePublisherRegistration();
            updateApplyButtonState();

            if (currentStream) {
              status.textContent = `Settings applied for ${selectedNickname}.`;
            } else {
              status.textContent = "Settings saved. Enable the camera to go live.";
            }
          });

          startCameraBtn.addEventListener("click", () => {
            startCameraBtn.disabled = true;
            status.textContent = "Requesting camera access...";
            startStream(pendingDeviceId || selectedCameraId || undefined);
          });

          loadPlayers();
          setCameraControlsEnabled(true);
          updateApplyButtonState();

          loadCameraDevices().catch(() => {
            status.textContent = "Unable to list cameras. Grant permission and try again.";
          });

          if (!mediaApisAvailable()) {
            status.textContent = "This browser does not support the camera API. Update or switch to Chrome/Edge/Firefox.";
            showStartButton();
          } else {
            setTimeout(() => {
              if (autoStartAttempted || currentStream) {
                return;
              }
              autoStartAttempted = true;
              startStream();
            }, 350);
          }

          startWebSocket();

          if (navigator.mediaDevices?.addEventListener) {
            navigator.mediaDevices.addEventListener("devicechange", () => {
              loadCameraDevices(selectedCameraId);
            });
          }

          window.addEventListener("beforeunload", () => {
            closeAllPeers();
            stopCurrentStream();
          });
        });
      </script>
