<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxy Battle | Camera Link</title>
  <style>
    :root {
      color-scheme: dark;
      --brand-primary: #221c3b;
      --brand-accent: #2f2658;
      --brand-pop: #6d5ad0;
      --brand-soft: #3a305f;
      --surface: rgba(24, 18, 48, 0.92);
      --surface-strong: rgba(29, 23, 57, 0.96);
      --border: rgba(109, 90, 208, 0.2);
      --text-main: #f5f2ff;
      --text-muted: rgba(245, 242, 255, 0.72);
      --success: #5bd997;
      --success-strong: #2eaf73;
      --success-soft: rgba(91, 217, 151, 0.28);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 40px 16px;
      font-family: "Montserrat", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text-main);
      background: radial-gradient(circle at 20% 20%, rgba(109, 90, 208, 0.25), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(58, 48, 95, 0.55), transparent 50%),
        linear-gradient(135deg, #120d25 0%, var(--brand-primary) 45%, #1b1532 100%);
    }

    .card {
      position: relative;
      width: 100%;
      max-width: 520px;
      padding: 32px;
      border-radius: 24px;
      background: var(--surface);
      border: 1px solid var(--border);
      box-shadow: 0 45px 90px rgba(11, 9, 22, 0.55), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(12px);
    }

    .card.connected {
      border-color: rgba(91, 217, 151, 0.75);
      box-shadow: 0 55px 110px rgba(20, 40, 32, 0.65), inset 0 0 0 1px rgba(91, 217, 151, 0.35);
    }

    .brand-chip {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 18px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.34em;
      font-size: 0.78rem;
      font-weight: 700;
      color: var(--text-main);
      background: rgba(109, 90, 208, 0.16);
      border: 1px solid rgba(109, 90, 208, 0.35);
      margin-bottom: 18px;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 1.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .subtitle {
      margin: 0 0 28px;
      font-size: 0.95rem;
      color: var(--text-muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    label {
      display: block;
      margin-bottom: 10px;
      font-size: 0.82rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    select,
    button {
      width: 100%;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      margin-bottom: 16px;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.06em;
    }

    select {
      background: var(--surface-strong);
      color: var(--text-main);
    }

    select:disabled {
      opacity: 0.55;
    }

    button {
      background: linear-gradient(145deg, var(--brand-pop), #4e3ca0);
      color: var(--text-main);
      cursor: pointer;
      border: none;
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      box-shadow: 0 22px 44px rgba(15, 12, 36, 0.55);
    }

    button:hover:not([disabled]) {
      transform: translateY(-2px);
      box-shadow: 0 26px 54px rgba(15, 12, 36, 0.65);
    }

    button:active:not([disabled]) {
      transform: translateY(0);
    }

    button.connected {
      background: linear-gradient(145deg, var(--success), var(--success-strong));
      box-shadow: 0 26px 52px rgba(25, 63, 44, 0.6);
    }

    button.secondary {
      background: transparent;
      border: 1px solid rgba(109, 90, 208, 0.32);
      box-shadow: none;
    }

    button.secondary:hover:not([disabled]) {
      background: rgba(109, 90, 208, 0.12);
    }

    #startCameraBtn {
      display: none;
      margin-top: -4px;
    }

    #applySelectionBtn[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    video {
      width: 100%;
      border-radius: 16px;
      background: rgba(12, 9, 28, 0.88);
      margin-bottom: 20px;
      border: 1px solid rgba(109, 90, 208, 0.24);
      box-shadow: inset 0 0 65px rgba(11, 9, 30, 0.65);
    }

    .hint {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 18px;
      letter-spacing: 0.04em;
    }

    .status {
      font-size: 0.85rem;
      color: var(--text-muted);
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div class="card">
    <span class="brand-chip">Galaxy Battle</span>
    <h1>Camera Link Console</h1>
    <p class="subtitle">Choose your nickname and camera to go live.</p>
    <label for="nicknameSelect">Select your nickname</label>
    <select id="nicknameSelect">
  <option value="">- choose nickname -</option>
    </select>
    <button id="refreshBtn" type="button" class="secondary">Refresh player list</button>

    <label for="cameraSelect">Select your camera</label>
    <select id="cameraSelect">
  <option value="">- default camera -</option>
    </select>
    <button id="cameraRefreshBtn" type="button" class="secondary">Refresh camera list</button>
  <button id="applySelectionBtn" type="button" disabled>Apply Selection</button>
    <button id="startCameraBtn" type="button">Enable camera</button>

    <video id="camPreview" autoplay playsinline muted></video>
  <p class="hint">If you don't see yourself in the list, join the game server.</p>
  <p class="status" id="status">Requesting camera access...</p>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
          const nicknameSelect = document.getElementById("nicknameSelect");
          const refreshBtn = document.getElementById("refreshBtn");
          const cameraSelect = document.getElementById("cameraSelect");
          const cameraRefreshBtn = document.getElementById("cameraRefreshBtn");
          const applySelectionBtn = document.getElementById("applySelectionBtn");
          const startCameraBtn = document.getElementById("startCameraBtn");
          const status = document.getElementById("status");
          const video = document.getElementById("camPreview");
          const card = document.querySelector(".card");

          const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];
          const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
          const hasSecureContext = window.isSecureContext || location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";

          const peers = new Map();
          const takenNicknames = new Set();

          let ws;
          let wsReady = false;
          let selectedNickname = "";
          let currentStream = null;
          let selectedCameraId = "";
          let pendingDeviceId = "";
          let autoStartAttempted = false;
          let lastAppliedNickname = "";
          let lastAppliedCameraId = "";
          let knownPlayers = [];
          let isConnected = false;

          function peerKey(viewerSocketId, connectionId) {
            return `${viewerSocketId}:${connectionId}`;
          }

          function mediaApisAvailable() {
            return (
              (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === "function") ||
              typeof navigator.getUserMedia === "function" ||
              typeof navigator.webkitGetUserMedia === "function" ||
              typeof navigator.mozGetUserMedia === "function"
            );
          }

          async function requestStream(constraints) {
            if (navigator.mediaDevices?.getUserMedia) {
              return navigator.mediaDevices.getUserMedia(constraints);
            }

            const legacy = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            if (legacy) {
              return new Promise((resolve, reject) => legacy.call(navigator, constraints, resolve, reject));
            }

            const error = new Error("MEDIA_NOT_SUPPORTED");
            error.code = "MEDIA_NOT_SUPPORTED";
            throw error;
          }

          async function loadPlayers() {
            try {
              const response = await fetch("/players", { cache: "no-store" });
              if (!response.ok) {
                throw new Error("Failed to load players");
              }

              const payload = await response.json();
              populateSelect(payload.players || []);
              updateApplyButtonState();
            } catch (error) {
              status.textContent = "Unable to load players. Try refreshing later.";
            }
          }

          function populateSelect(players) {
            if (Array.isArray(players)) {
              knownPlayers = [...players];
            }

            const previousValue = nicknameSelect.value;
            const desiredValue = selectedNickname || previousValue;

            nicknameSelect.innerHTML = "";

            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "- choose nickname -";
            nicknameSelect.appendChild(placeholder);

            let restoredValue = "";

            for (const name of knownPlayers) {
              if (typeof name !== "string" || !name.trim()) {
                continue;
              }

              const option = document.createElement("option");
              option.value = name;

              const takenByOther = takenNicknames.has(name) && name !== lastAppliedNickname;
              if (takenByOther) {
                option.disabled = true;
                option.textContent = `${name} - taken`;
              } else {
                option.textContent = name;
              }

              nicknameSelect.appendChild(option);

              if (!takenByOther && name === desiredValue) {
                restoredValue = name;
              }
            }

            if (restoredValue) {
              nicknameSelect.value = restoredValue;
              selectedNickname = restoredValue;
            } else {
              nicknameSelect.value = "";
              if (selectedNickname && takenNicknames.has(selectedNickname) && selectedNickname !== lastAppliedNickname) {
                selectedNickname = "";
                status.textContent = "That nickname is already taken. Please pick another.";
              }
            }

            updateApplyButtonState();
          }

          function sendSignal(payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(payload));
            }
          }

          function ensurePublisherRegistration() {
            if (!wsReady || !selectedNickname || !currentStream) {
              return;
            }

            if (selectedNickname !== lastAppliedNickname) {
              return;
            }
            sendSignal({ type: "HELLO", role: "publisher", nickname: selectedNickname });
          }

          function cleanupPeer(key, notifyServer = true) {
            const session = peers.get(key);
            if (!session) {
              return;
            }

            peers.delete(key);

            try {
              session.pc.onicecandidate = null;
              session.pc.onconnectionstatechange = null;
              session.pc.close();
            } catch (error) {
              console.warn("Failed to close peer cleanly", error);
            }

            if (notifyServer) {
              sendSignal({
                type: "PUBLISHER_PEER_CLOSED",
                viewerSocketId: session.viewerSocketId,
                connectionId: session.connectionId,
                nickname: session.nickname,
              });
            }
          }

          function updateApplyButtonState() {
            const nicknameReady = Boolean(selectedNickname);
            const cameraReady = Boolean(selectedCameraId || currentStream);
            const sameSelection =
              nicknameReady &&
              cameraReady &&
              selectedNickname === lastAppliedNickname &&
              selectedCameraId === lastAppliedCameraId;

            applySelectionBtn.disabled = !(nicknameReady && cameraReady);

            if (!sameSelection && isConnected) {
              setConnected(false);
            }

            if (!nicknameReady || !cameraReady) {
              applySelectionBtn.textContent = "Apply Selection";
              return;
            }

            if (isConnected && sameSelection) {
              applySelectionBtn.textContent = "Connected";
            } else {
              applySelectionBtn.textContent = "Apply Selection";
            }
          }

          function setConnected(state) {
            if (isConnected === state) {
              return;
            }
            isConnected = state;
            if (card) {
              card.classList.toggle("connected", state);
            }
            applySelectionBtn.classList.toggle("connected", state);
          }

          function updateTakenNicknames(list) {
            takenNicknames.clear();

            if (Array.isArray(list)) {
              for (const name of list) {
                if (typeof name === "string" && name.trim()) {
                  takenNicknames.add(name.trim());
                }
              }
            }

            populateSelect();

            if (isConnected && lastAppliedNickname && !takenNicknames.has(lastAppliedNickname)) {
              setConnected(false);
              if (selectedNickname === lastAppliedNickname) {
                status.textContent = "You were disconnected. Apply selection again.";
              }
              updateApplyButtonState();
            }
          }

          function closeAllPeers() {
            for (const key of Array.from(peers.keys())) {
              cleanupPeer(key, true);
            }
          }

          function buildPublisherPeer({ viewerSocketId, connectionId, nickname }) {
            const key = peerKey(viewerSocketId, connectionId);
            const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            peers.set(key, { pc, viewerSocketId, connectionId, nickname });

            if (currentStream) {
              currentStream.getTracks().forEach((track) => pc.addTrack(track, currentStream));
            }

            pc.onicecandidate = (event) => {
              if (!event.candidate) {
                return;
              }
              sendSignal({
                type: "PUBLISHER_ICE",
                viewerSocketId,
                connectionId,
                candidate: event.candidate,
              });
            };

            pc.onconnectionstatechange = () => {
              if (pc.connectionState === "failed" || pc.connectionState === "disconnected" || pc.connectionState === "closed") {
                cleanupPeer(key, pc.connectionState !== "closed");
              }
            };

            return pc;
          }

          async function handleViewerOffer(payload) {
            if (!currentStream) {
              status.textContent = "Camera preview is offline. Start the feed first.";
              return;
            }

            const { viewerSocketId, connectionId, nickname, sdp } = payload;
            const key = peerKey(viewerSocketId, connectionId);

            if (peers.has(key)) {
              cleanupPeer(key, true);
            }

            const pc = buildPublisherPeer({ viewerSocketId, connectionId, nickname });

            try {
              await pc.setRemoteDescription(sdp);
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);

              sendSignal({
                type: "PUBLISHER_ANSWER",
                viewerSocketId,
                connectionId,
                sdp: pc.localDescription,
              });
            } catch (error) {
              console.error("Failed to process viewer offer", error);
              status.textContent = "WebRTC negotiation failed. Refresh the page and try again.";
              cleanupPeer(key, true);
            }
          }

          async function handleViewerCandidate(payload) {
            const { viewerSocketId, connectionId, candidate } = payload;
            const key = peerKey(viewerSocketId, connectionId);
            const session = peers.get(key);
            if (!session) {
              return;
            }

            try {
              await session.pc.addIceCandidate(candidate || null);
            } catch (error) {
              console.error("Failed to apply ICE candidate", error);
            }
          }

          function handleViewerDisconnected(payload) {
            const { viewerSocketId, connectionId } = payload;
            cleanupPeer(peerKey(viewerSocketId, connectionId), false);
          }

          function startWebSocket() {
            ws = new WebSocket(wsUrl);

            ws.addEventListener("open", () => {
              wsReady = true;
              status.textContent = "Connected to the server. Pick your nickname and enable the camera.";
              ensurePublisherRegistration();
            });

            ws.addEventListener("message", (event) => {
              let payload;
              try {
                payload = JSON.parse(event.data);
              } catch (error) {
                return;
              }

              switch (payload.type) {
                case "SIGNAL_VIEWER_OFFER":
                  handleViewerOffer(payload);
                  break;
                case "SIGNAL_VIEWER_CANDIDATE":
                  handleViewerCandidate(payload);
                  break;
                case "VIEWER_DISCONNECTED":
                  handleViewerDisconnected(payload);
                  break;
                case "WELCOME":
                  if (Array.isArray(payload.publishers)) {
                    updateTakenNicknames(payload.publishers);
                  }
                  break;
                case "ACTIVE_PUBLISHERS":
                  updateTakenNicknames(payload.publishers);
                  break;
                case "PUBLISHER_REGISTERED": {
                  const nickname = payload.nickname;
                  if (nickname === lastAppliedNickname) {
                    status.textContent = `Camera ${nickname} is live for viewers.`;
                    setConnected(true);
                    updateApplyButtonState();
                  }
                  if (nickname) {
                    takenNicknames.add(nickname);
                    populateSelect();
                  }
                  break;
                }
                case "ERROR":
                  status.textContent = payload.message || "Server error.";
                  if ((payload.message || "").toLowerCase().includes("already in use")) {
                    setConnected(false);
                    updateApplyButtonState();
                  }
                  break;
                default:
                  break;
              }
            });

            ws.addEventListener("close", () => {
              wsReady = false;
              closeAllPeers();
              setConnected(false);
              status.textContent = "Connection closed. Reconnecting...";
              updateApplyButtonState();
              setTimeout(startWebSocket, 2000);
            });

            ws.addEventListener("error", () => {
              status.textContent = "Connection error. Refresh the page if it persists.";
            });
          }

          function stopCurrentStream() {
            closeAllPeers();
            if (currentStream) {
              currentStream.getTracks().forEach((track) => track.stop());
              currentStream = null;
            }
            video.srcObject = null;
            setConnected(false);
            updateApplyButtonState();
          }

          function showStartButton(message) {
            if (message) {
              status.textContent = message;
            }
            startCameraBtn.style.display = "block";
            startCameraBtn.disabled = false;
          }

          function hideStartButton() {
            startCameraBtn.style.display = "none";
          }

          function setCameraControlsEnabled(enabled) {
            cameraSelect.disabled = !enabled;
            cameraRefreshBtn.disabled = !enabled;
          }

          async function loadCameraDevices(preferredId = "") {
            if (!navigator.mediaDevices?.enumerateDevices) {
              return;
            }

            try {
              const devices = await navigator.mediaDevices.enumerateDevices();
              const videoInputs = devices.filter((device) => device.kind === "videoinput");

              const currentValue = preferredId || pendingDeviceId || selectedCameraId || cameraSelect.value;

              cameraSelect.innerHTML = "";
              if (videoInputs.length === 0) {
                const option = document.createElement("option");
                option.value = "";
                option.textContent = "No camera found";
                cameraSelect.appendChild(option);
                cameraSelect.disabled = true;
                updateApplyButtonState();
                return;
              }

              cameraSelect.disabled = false;

              videoInputs.forEach((device, index) => {
                const option = document.createElement("option");
                option.value = device.deviceId;
                option.textContent = device.label || `Camera ${index + 1}`;
                cameraSelect.appendChild(option);
              });

              const matched = videoInputs.some((device) => device.deviceId === currentValue);
              if (matched) {
                cameraSelect.value = currentValue;
              } else {
                cameraSelect.selectedIndex = 0;
                selectedCameraId = cameraSelect.value;
              }

              updateApplyButtonState();
            } catch (error) {
              console.error("Failed to enumerate cameras", error);
              updateApplyButtonState();
            }
          }

          async function startStream(deviceId, allowFallback = true) {
            autoStartAttempted = true;
            stopCurrentStream();

            try {
              const constraints = {
                video: {
                  width: { ideal: 1280 },
                  height: { ideal: 720 },
                  frameRate: { ideal: 30 },
                },
                audio: false,
              };

              if (deviceId) {
                constraints.video.deviceId = { exact: deviceId };
              } else {
                constraints.video.facingMode = { ideal: "user" };
              }

              const stream = await requestStream(constraints);
              currentStream = stream;
              video.srcObject = stream;

              const activeTrack = stream.getVideoTracks()[0];
              if (activeTrack?.applyConstraints) {
                try {
                  await activeTrack.applyConstraints({
                    width: { ideal: 1280, max: 1280 },
                    height: { ideal: 720, max: 720 },
                    frameRate: { ideal: 30, max: 30 },
                  });
                } catch (applyError) {
                  console.warn("Failed to apply advanced camera constraints", applyError);
                }
              }

              const appliedDeviceId = activeTrack?.getSettings?.().deviceId || deviceId || "";
              selectedCameraId = appliedDeviceId;
              pendingDeviceId = "";
              await loadCameraDevices(appliedDeviceId);
              status.textContent = "Camera feed is ready. Apply your selection to go live.";
              hideStartButton();
              setCameraControlsEnabled(true);
              ensurePublisherRegistration();
              updateApplyButtonState();
            } catch (error) {
              console.error("getUserMedia error", error);
              stopCurrentStream();
              setCameraControlsEnabled(true);

              const errorName = error?.name || "";
              const errorMessage = (error?.message || "").toLowerCase();

              if (error?.code === "MEDIA_NOT_SUPPORTED") {
                status.textContent = "This browser does not support camera APIs. Switch to a modern browser or HTTPS.";
                showStartButton();
                updateApplyButtonState();
                return;
              }

              if (!hasSecureContext) {
                status.textContent = "Camera access requires HTTPS or launching from localhost.";
                showStartButton();
                updateApplyButtonState();
                return;
              }

              if (allowFallback && deviceId) {
                pendingDeviceId = "";
                status.textContent = "Selected camera failed to start. Falling back to the default device.";
                setTimeout(() => startStream(undefined, false), 200);
                showStartButton();
                updateApplyButtonState();
                return;
              }

              if (errorName === "NotAllowedError" || errorName === "SecurityError" || errorMessage.includes("gesture")) {
                showStartButton("Click \"Enable camera\" and grant permission to the browser.");
              } else if (errorName === "NotFoundError") {
                status.textContent = "No camera detected. Plug in a device and press \"Enable camera\".";
                showStartButton();
              } else if (errorName === "AbortError") {
                status.textContent = "Camera failed to start. Try again.";
                showStartButton();
              } else if (errorName === "OverconstrainedError" || errorMessage.includes("start video source") || errorMessage.includes("could not start")) {
                status.textContent = "Camera cannot start with the current constraints. Choose another device.";
                showStartButton();
              } else {
                status.textContent = "Camera error: " + (error?.message || "Unknown error");
                showStartButton();
              }
              updateApplyButtonState();
            }
          }

          nicknameSelect.addEventListener("change", () => {
            selectedNickname = nicknameSelect.value;
            if (!selectedNickname) {
              status.textContent = "Choose your nickname and camera, then press \"Apply Selection\".";
            } else if (selectedNickname !== lastAppliedNickname) {
              status.textContent = `Selected ${selectedNickname}. Don't forget to press \"Apply Selection\".`;
            }
            if (selectedNickname !== lastAppliedNickname) {
              setConnected(false);
            }
            updateApplyButtonState();
          });

          refreshBtn.addEventListener("click", () => {
            loadPlayers();
          });

          cameraSelect.addEventListener("change", () => {
            const deviceId = cameraSelect.value;
            pendingDeviceId = deviceId || "";
            if (currentStream && deviceId && deviceId !== selectedCameraId) {
              startStream(deviceId);
            }
            if (!currentStream) {
              selectedCameraId = pendingDeviceId;
            }
            if (selectedNickname && (selectedNickname !== lastAppliedNickname || (deviceId || "") !== lastAppliedCameraId)) {
              status.textContent = "Settings changed. Press \"Apply Selection\" to confirm.";
            }
            if ((deviceId || "") !== lastAppliedCameraId) {
              setConnected(false);
            }
            updateApplyButtonState();
          });

          cameraRefreshBtn.addEventListener("click", () => {
            loadCameraDevices();
          });

          applySelectionBtn.addEventListener("click", () => {
            if (applySelectionBtn.disabled) {
              return;
            }

            if (!selectedNickname) {
              status.textContent = "Select a nickname before applying settings.";
              return;
            }

            if (!selectedCameraId && pendingDeviceId) {
              selectedCameraId = pendingDeviceId;
            }
            if (!selectedCameraId) {
              selectedCameraId = cameraSelect.value || "";
            }

            const previousNickname = lastAppliedNickname;
            const previousCameraId = lastAppliedCameraId;
            lastAppliedNickname = selectedNickname;
            lastAppliedCameraId = selectedCameraId;

            if (previousNickname !== lastAppliedNickname || previousCameraId !== lastAppliedCameraId) {
              setConnected(false);
            }

            ensurePublisherRegistration();
            updateApplyButtonState();

            if (currentStream) {
              status.textContent = `Settings applied for ${selectedNickname}.`;
            } else {
              status.textContent = "Settings saved. Enable the camera to go live.";
            }
          });

          startCameraBtn.addEventListener("click", () => {
            startCameraBtn.disabled = true;
            status.textContent = "Requesting camera access...";
            startStream(pendingDeviceId || selectedCameraId || undefined);
          });

          loadPlayers();
          setCameraControlsEnabled(true);
          updateApplyButtonState();

          loadCameraDevices().catch(() => {
            status.textContent = "Unable to list cameras. Grant permission and try again.";
          });

          if (!mediaApisAvailable()) {
            status.textContent = "This browser does not support the camera API. Update or switch to Chrome/Edge/Firefox.";
            showStartButton();
          } else {
            setTimeout(() => {
              if (autoStartAttempted || currentStream) {
                return;
              }
              autoStartAttempted = true;
              startStream();
            }, 350);
          }

          startWebSocket();

          if (navigator.mediaDevices?.addEventListener) {
            navigator.mediaDevices.addEventListener("devicechange", () => {
              loadCameraDevices(selectedCameraId);
            });
          }

          window.addEventListener("beforeunload", () => {
            closeAllPeers();
            stopCurrentStream();
          });
        });
      </script>
