<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Broadcast Admin Console</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #111324;
      --panel: #191c33;
      --panel-alt: #202441;
      --primary: #6d8bff;
      --accent: #4b66ff;
      --danger: #ff6b6b;
      --text: #f5f7ff;
      --muted: rgba(245, 247, 255, 0.65);
      --border: rgba(255, 255, 255, 0.1);
      --success: #5bd997;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    h1 {
      margin: 0;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-size: 1.8rem;
    }

    nav {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    nav a {
      text-decoration: none;
      padding: 8px 14px;
      border-radius: 999px;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      transition: background 0.2s ease;
    }

    nav a:hover {
      background: var(--panel-alt);
    }

    main {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 24px;
    }

    section {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 0;
    }

    h2 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
    }

    th, td {
      border-bottom: 1px solid var(--border);
      padding: 10px 6px;
      text-align: left;
    }

    th {
      font-weight: 600;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-size: 0.75rem;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    input, button {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel-alt);
      color: var(--text);
      font-size: 0.95rem;
    }

    input:focus {
      outline: 2px solid var(--primary);
    }

    button {
      cursor: pointer;
      border: none;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 600;
    }

    button.danger {
      background: linear-gradient(135deg, var(--danger), #cc5454);
    }

    button.secondary {
      background: transparent;
      border: 1px solid var(--border);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .status-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }

    .status-card {
      background: var(--panel-alt);
      border-radius: 14px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      border: 1px solid var(--border);
    }

    .status-card span {
      font-size: 0.75rem;
      color: var(--muted);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .status-card strong {
      font-size: 1.1rem;
    }

    #messageBox {
      min-height: 22px;
      font-size: 0.88rem;
      color: var(--success);
    }

    .error {
      color: var(--danger);
    }

    @media (max-width: 640px) {
      body {
        padding: 16px;
      }

      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Broadcast Control Center</h1>
    <div id="messageBox"></div>
    <nav id="navLinks"></nav>
    <div class="status-board">
      <div class="status-card">
        <span>Current Focus</span>
        <strong id="focusName">—</strong>
      </div>
      <div class="status-card">
        <span>Active Cameras</span>
        <strong id="cameraCount">0</strong>
      </div>
      <div class="status-card">
        <span>Last Sync</span>
        <strong id="updatedAt">—</strong>
      </div>
    </div>
  </header>

  <main>
    <section>
      <h2>Allowed Admin IPs</h2>
      <table>
        <thead>
          <tr>
            <th>IP Address</th>
            <th>Label</th>
            <th>Added</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="ipTableBody"></tbody>
      </table>

      <form id="addIpForm">
        <label for="ipInput">Add new admin IP</label>
        <input id="ipInput" name="ip" type="text" placeholder="e.g. 203.0.113.5" required>
        <label for="labelInput">Label (nickname)</label>
        <input id="labelInput" name="label" type="text" placeholder="Who is this for?">
        <button type="submit">Add IP</button>
      </form>
    </section>

    <section>
      <h2>Active Cameras</h2>
      <table>
        <thead>
          <tr>
            <th>Nickname</th>
            <th>Team</th>
            <th>Status</th>
            <th>Viewers</th>
            <th>Connections</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="cameraTableBody"></tbody>
      </table>
    </section>
  </main>

  <script>
  const DASHBOARD_ENDPOINT = "/api/admin/dashboard";
  const ADD_IP_ENDPOINT = "/api/admin/allowed-ips";
  const KICK_ENDPOINT = "/api/admin/kick";
  const RENAME_ENDPOINT = "/api/admin/rename";

    let ownerIp = "";

    const messageBox = document.getElementById("messageBox");
    const focusName = document.getElementById("focusName");
    const updatedAt = document.getElementById("updatedAt");
    const cameraCount = document.getElementById("cameraCount");
    const navLinks = document.getElementById("navLinks");
    const ipTableBody = document.getElementById("ipTableBody");
    const cameraTableBody = document.getElementById("cameraTableBody");

    function setMessage(message, isError = false) {
      messageBox.textContent = message || "";
      messageBox.classList.toggle("error", Boolean(isError));
    }

    function formatDate(isoString) {
      if (!isoString) {
        return "—";
      }
      try {
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return isoString;
        }
        return date.toLocaleString();
      } catch (error) {
        return isoString;
      }
    }

    function renderNav(links) {
      navLinks.innerHTML = "";
      links.forEach((link) => {
        const anchor = document.createElement("a");
        anchor.href = link.href;
        anchor.textContent = link.label;
        anchor.target = "_blank";
        anchor.rel = "noreferrer";
        navLinks.appendChild(anchor);
      });
    }

    function renderIps(items) {
      ipTableBody.innerHTML = "";

      if (!items.length) {
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = 4;
        cell.textContent = "No IPs yet";
        cell.style.color = "var(--muted)";
        row.appendChild(cell);
        ipTableBody.appendChild(row);
        return;
      }

      items.forEach((entry) => {
        const row = document.createElement("tr");

        const ipCell = document.createElement("td");
        ipCell.textContent = entry.ip;
        row.appendChild(ipCell);

        const labelCell = document.createElement("td");
        labelCell.textContent = entry.label || "—";
        row.appendChild(labelCell);

        const dateCell = document.createElement("td");
        dateCell.textContent = formatDate(entry.addedAt);
        row.appendChild(dateCell);

        const actionCell = document.createElement("td");
        if (entry.ip !== ownerIp) {
          const removeBtn = document.createElement("button");
          removeBtn.className = "danger";
          removeBtn.type = "button";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => handleRemoveIp(entry.ip));
          actionCell.appendChild(removeBtn);
        } else {
          const badge = document.createElement("span");
          badge.className = "tag";
          badge.textContent = "Primary";
          actionCell.appendChild(badge);
        }
        row.appendChild(actionCell);

        ipTableBody.appendChild(row);
      });
    }

    function renderPlayersBoard(data) {
      cameraTableBody.innerHTML = "";

      const publishers = Array.isArray(data?.publishers) ? data.publishers : [];
      const roster = Array.isArray(data?.roster) ? data.roster : [];

      const statsByKey = new Map();
      publishers.forEach((entry) => {
        const nickname = typeof entry.nickname === "string" ? entry.nickname.trim() : "";
        if (!nickname) {
          return;
        }
        statsByKey.set(nickname.toLowerCase(), {
          nickname,
          viewers: Number(entry.uniqueViewers || 0),
          connections: Number(entry.connections || 0),
        });
      });

      const rows = [];
      const seen = new Set();

      roster.forEach((player) => {
        const nickname = typeof player?.name === "string" ? player.name.trim() : "";
        if (!nickname) {
          return;
        }
        const key = nickname.toLowerCase();
        if (seen.has(key)) {
          return;
        }
        seen.add(key);
        const stats = statsByKey.get(key);
        rows.push({
          nickname,
          team: typeof player?.team === "string" ? player.team.trim().toUpperCase() : "",
          online: Boolean(stats),
          viewers: stats?.viewers ?? 0,
          connections: stats?.connections ?? 0,
        });
      });

      publishers.forEach((entry) => {
        const nickname = typeof entry.nickname === "string" ? entry.nickname.trim() : "";
        if (!nickname) {
          return;
        }
        const key = nickname.toLowerCase();
        if (seen.has(key)) {
          return;
        }
        seen.add(key);
        rows.push({
          nickname,
          team: "",
          online: true,
          viewers: Number(entry.uniqueViewers || 0),
          connections: Number(entry.connections || 0),
        });
      });

      if (!rows.length) {
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = 6;
        cell.textContent = "No players available";
        cell.style.color = "var(--muted)";
        row.appendChild(cell);
        cameraTableBody.appendChild(row);
        cameraCount.textContent = "0";
        return;
      }

      rows.sort((a, b) => {
        const teamA = a.team || "ZZ";
        const teamB = b.team || "ZZ";
        if (teamA !== teamB) {
          return teamA.localeCompare(teamB);
        }
        if (a.online !== b.online) {
          return a.online ? -1 : 1;
        }
        return a.nickname.localeCompare(b.nickname);
      });

      let onlineCount = 0;

      rows.forEach((player) => {
        if (player.online) {
          onlineCount += 1;
        }

        const row = document.createElement("tr");

        const nicknameCell = document.createElement("td");
        nicknameCell.textContent = player.nickname;
        row.appendChild(nicknameCell);

        const teamCell = document.createElement("td");
        teamCell.textContent = player.team || "—";
        row.appendChild(teamCell);

        const statusCell = document.createElement("td");
        statusCell.textContent = player.online ? "Online" : "Offline";
        statusCell.style.color = player.online ? "var(--success)" : "var(--muted)";
        row.appendChild(statusCell);

        const viewersCell = document.createElement("td");
        viewersCell.textContent = player.viewers.toString();
        row.appendChild(viewersCell);

        const connectionsCell = document.createElement("td");
        connectionsCell.textContent = player.connections.toString();
        row.appendChild(connectionsCell);

        const actionsCell = document.createElement("td");
        actionsCell.style.display = "flex";
        actionsCell.style.gap = "8px";

        const renameBtn = document.createElement("button");
        renameBtn.type = "button";
        renameBtn.className = "secondary";
        renameBtn.textContent = "Rename";
        renameBtn.addEventListener("click", () => handleRename(player.nickname));
        actionsCell.appendChild(renameBtn);

        const kickBtn = document.createElement("button");
        kickBtn.type = "button";
        kickBtn.className = "danger";
        kickBtn.textContent = "Kick";
        kickBtn.disabled = !player.online;
        kickBtn.addEventListener("click", () => handleKick(player.nickname));
        actionsCell.appendChild(kickBtn);

        row.appendChild(actionsCell);

        cameraTableBody.appendChild(row);
      });

      cameraCount.textContent = onlineCount.toString();
    }

    async function handleRemoveIp(ip) {
      if (!window.confirm(`Remove ${ip} from the allowlist?`)) {
        return;
      }
      try {
        const response = await fetch(`${ADD_IP_ENDPOINT}/${encodeURIComponent(ip)}`, {
          method: "DELETE",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to remove IP");
        }
        setMessage(`Removed ${ip} from the allowlist.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to remove IP", true);
      }
    }

    async function handleKick(nickname) {
      if (!window.confirm(`Kick camera for ${nickname}?`)) {
        return;
      }
      try {
        const response = await fetch(KICK_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nickname }),
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to kick camera");
        }
        setMessage(`Camera ${nickname} disconnected.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to kick camera", true);
      }
    }

    async function handleRename(oldNickname) {
      const proposed = window.prompt("Enter new nickname", oldNickname);
      if (proposed === null) {
        return;
      }

      const newNickname = proposed.trim();
      if (!newNickname) {
        setMessage("Nickname cannot be empty", true);
        return;
      }

      if (newNickname === oldNickname) {
        setMessage("Nickname unchanged", true);
        return;
      }

      try {
        const response = await fetch(RENAME_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ oldNickname, newNickname }),
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to rename player");
        }
        setMessage(`Renamed ${oldNickname} to ${newNickname}.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to rename player", true);
      }
    }

    async function loadDashboard() {
      try {
        const response = await fetch(DASHBOARD_ENDPOINT, { cache: "no-store" });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Failed to load dashboard");
        }

        const data = await response.json();
        ownerIp = data.ownerIp;
        const focus = data.currentFocus || null;
        focusName.textContent = focus || "—";
        updatedAt.textContent = formatDate(data.updatedAt);
        renderNav(Array.isArray(data.siteLinks) ? data.siteLinks : []);
  renderIps(Array.isArray(data.allowedIps) ? data.allowedIps : []);
  renderPlayersBoard(data);
      } catch (error) {
        setMessage(error.message || "Dashboard connection failed", true);
      }
    }

    document.getElementById("addIpForm").addEventListener("submit", async (event) => {
      event.preventDefault();
      const ip = event.target.ip.value.trim();
      const label = event.target.label.value.trim();
      if (!ip) {
        setMessage("Enter an IPv4 address", true);
        return;
      }
      try {
        const response = await fetch(ADD_IP_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ip, label }),
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to add IP");
        }
        event.target.reset();
        setMessage(`Added ${ip} to the allowlist.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to add IP", true);
      }
    });

    loadDashboard();
    setInterval(loadDashboard, 5000);
  </script>
</body>
</html>
