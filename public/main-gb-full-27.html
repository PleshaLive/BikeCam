<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Current Focus Feed</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
    }

    .feed-stack {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .feed-layer {
      position: absolute;
      inset: 0;
      width: 0;
      height: 0;
      object-fit: cover;
      background: transparent;
      display: none;
    }
  </style>
</head>
<body>
  <div class="stage">
    <div class="feed-stack">
      <video id="feedA" class="feed-layer" autoplay playsinline muted></video>
      <video id="feedB" class="feed-layer" autoplay playsinline muted></video>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const feedStack = document.querySelector(".feed-stack");
      const videoLayers = Array.from(feedStack?.querySelectorAll(".feed-layer") || []);

      while (feedStack && videoLayers.length < 2) {
        const layer = document.createElement("video");
        layer.autoplay = true;
        layer.playsInline = true;
        layer.muted = true;
        layer.className = "feed-layer";
        feedStack.appendChild(layer);
        videoLayers.push(layer);
      }

      if (!feedStack || videoLayers.length < 2) {
        console.error("Unable to initialize video layers for the focus page.");
        return;
      }
      const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

      let ws;
      let wsReady = false;
      let viewerRegistered = false;
      let reconnectTimer = null;
      let connectionCounter = 0;

      const knownPublishers = new Set();
      const sessions = new Map();

      let desiredFocus = null;
  let displayedStream = null;
  let displayedNickname = null;
  let activeVideoIndex = 0;
  let swapToken = 0;

      function normalizeNickname(name) {
        if (typeof name !== "string") {
          return null;
        }
        const trimmed = name.trim();
        return trimmed.length ? trimmed : null;
      }

      function createConnectionId() {
        connectionCounter += 1;
        return `viewer-${Date.now()}-${connectionCounter}`;
      }

      function playVideoSafe(video) {
        const attempt = video.play?.();
        if (!attempt || typeof attempt.then !== "function") {
          return Promise.resolve();
        }
        return attempt.catch(() => {});
      }

      function waitForFirstFrame(video) {
        if (video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA && video.currentTime > 0) {
          return Promise.resolve();
        }

        return new Promise((resolve) => {
          let frameHandle = null;

          const cleanup = () => {
            video.removeEventListener("playing", onPlaying);
            video.removeEventListener("timeupdate", onTimeUpdate);
            if (frameHandle !== null && typeof video.cancelVideoFrameCallback === "function") {
              video.cancelVideoFrameCallback(frameHandle);
            }
          };

          const finish = () => {
            cleanup();
            resolve();
          };

          const onPlaying = () => {
            finish();
          };

          const onTimeUpdate = () => {
            if (video.currentTime > 0) {
              finish();
            }
          };

          video.addEventListener("playing", onPlaying, { once: true });
          video.addEventListener("timeupdate", onTimeUpdate);

          if (typeof video.requestVideoFrameCallback === "function") {
            frameHandle = video.requestVideoFrameCallback(() => {
              finish();
            });
          }
        });
      }

      function ensureVideoVisible(video) {
        if (!video) {
          return;
        }
        video.style.display = "block";
        video.style.width = "100vw";
        video.style.height = "100vh";
        if (!video.style.zIndex) {
          video.style.zIndex = "1";
        }
      }

      function hideVideoLayer(video) {
        if (!video) {
          return;
        }
        video.pause?.();
        video.srcObject = null;
        video.style.display = "none";
        video.style.width = "0";
        video.style.height = "0";
        video.style.zIndex = "0";
      }

      function setDisplay(stream, nickname) {
        const nextStream = stream || null;

        if (!nextStream) {
          swapToken += 1;
          displayedStream = null;
          displayedNickname = null;
          activeVideoIndex = 0;
          for (const layer of videoLayers) {
            hideVideoLayer(layer);
          }
          return;
        }

        if (displayedStream === nextStream) {
          displayedNickname = nickname || displayedNickname;
          ensureVideoVisible(videoLayers[activeVideoIndex]);
          const activeLayer = videoLayers[activeVideoIndex];
          if (activeLayer) {
            activeLayer.style.zIndex = "2";
          }
          return;
        }

        const targetIndex = displayedStream ? (activeVideoIndex === 0 ? 1 : 0) : activeVideoIndex;
        const targetVideo = videoLayers[targetIndex];
        const previousVideo = videoLayers[activeVideoIndex];
        const currentToken = ++swapToken;

        if (displayedStream) {
          ensureVideoVisible(previousVideo);
          previousVideo.style.zIndex = "2";
        }
        ensureVideoVisible(targetVideo);
        targetVideo.style.zIndex = displayedStream ? "1" : "2";
        if (targetVideo.srcObject !== nextStream) {
          targetVideo.srcObject = nextStream;
        }

        playVideoSafe(targetVideo)
          .then(() => waitForFirstFrame(targetVideo))
          .then(() => {
            if (currentToken !== swapToken) {
              return;
            }

            const otherIndex = targetIndex === 0 ? 1 : 0;
            const otherVideo = videoLayers[otherIndex];
            if (otherVideo !== targetVideo) {
              hideVideoLayer(otherVideo);
            }

            targetVideo.style.zIndex = "2";

            displayedStream = nextStream;
            displayedNickname = nickname || null;
            activeVideoIndex = targetIndex;
          })
          .catch((error) => {
            console.error("Failed to render stream", error);
          });
      }

      function updateDisplay() {
        if (!desiredFocus) {
          if (displayedStream) {
            setDisplay(null, null);
          }
          return;
        }

        const session = sessions.get(desiredFocus);

        if (session?.stream) {
          if (displayedStream !== session.stream) {
            setDisplay(session.stream, session.nickname);
          }
          return;
        }

        if (!sessions.has(desiredFocus)) {
          if (displayedStream) {
            setDisplay(null, null);
          }
          return;
        }

        if (displayedStream && displayedNickname !== desiredFocus) {
          // Keep the previous stream visible until the new one appears to avoid flicker.
          return;
        }

        if (!displayedStream) {
          setDisplay(null, null);
        }
      }

      function sendSignal(payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(payload));
        }
      }

      function cleanupSession(nickname, { notify = true } = {}) {
        const session = sessions.get(nickname);
        if (!session) {
          return;
        }

        sessions.delete(nickname);

        if (notify && wsReady) {
          sendSignal({
            type: "VIEWER_STOP",
            nickname,
            connectionId: session.connectionId,
          });
        }

        try {
          session.pc.ontrack = null;
          session.pc.onicecandidate = null;
          session.pc.onconnectionstatechange = null;
          session.pc.close();
        } catch (error) {
    console.warn("Failed to close peer", error);
        }

        if (session.stream) {
          session.stream.getTracks().forEach((track) => track.stop());
        }

        if (displayedNickname === nickname) {
          setDisplay(null, null);
        }
      }

      function cleanupAllSessions({ notify = false } = {}) {
        for (const nickname of Array.from(sessions.keys())) {
          cleanupSession(nickname, { notify });
        }
      }

      function restartSession(nickname) {
        if (!knownPublishers.has(nickname)) {
          cleanupSession(nickname, { notify: true });
          return;
        }

        const hadSession = sessions.has(nickname);
        cleanupSession(nickname, { notify: true });

        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (hadSession) {
          Promise.resolve().then(() => startSession(nickname));
        }
      }

      async function startSession(nickname) {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (!knownPublishers.has(nickname)) {
          return;
        }

        if (sessions.has(nickname)) {
          return;
        }

        const connectionId = createConnectionId();
        const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        const session = { nickname, connectionId, pc, stream: null };
        sessions.set(nickname, session);

        pc.ontrack = (event) => {
          const [stream] = event.streams || [];
          if (!stream) {
            return;
          }

          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            stream.getTracks().forEach((track) => track.stop());
            return;
          }

          current.stream = stream;
          if (desiredFocus === nickname) {
            setDisplay(stream, nickname);
          }
        };

        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            return;
          }
          sendSignal({
            type: "VIEWER_ICE",
            nickname,
            connectionId,
            candidate: event.candidate,
          });
        };

        pc.onconnectionstatechange = () => {
          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            return;
          }

          if (pc.connectionState === "connected") {
            return;
          }

          if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
            restartSession(nickname);
          } else if (pc.connectionState === "closed") {
            cleanupSession(nickname, { notify: false });
          }
        };

        try {
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);

          sendSignal({
            type: "VIEWER_OFFER",
            nickname,
            connectionId,
            sdp: pc.localDescription,
          });
        } catch (error) {
      console.error("Failed to start WebRTC session", error);
          restartSession(nickname);
        }
      }

      function syncSessions() {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        for (const nickname of knownPublishers) {
          if (!sessions.has(nickname)) {
            startSession(nickname);
          }
        }

        for (const nickname of Array.from(sessions.keys())) {
          if (!knownPublishers.has(nickname)) {
            cleanupSession(nickname, { notify: true });
          }
        }

        updateDisplay();
      }

      function handlePublisherAnswer(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        session.pc.setRemoteDescription(payload.sdp).catch((error) => {
      console.error("Failed to apply answer", error);
          restartSession(nickname);
        });
      }

      async function handlePublisherCandidate(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        try {
          await session.pc.addIceCandidate(payload.candidate || null);
        } catch (error) {
      console.error("ICE candidate error", error);
        }
      }

      function handleStreamUnavailable(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        restartSession(nickname);
      }

      function handleActivePublishers(list) {
        knownPublishers.clear();

        if (Array.isArray(list)) {
          for (const name of list) {
            const normalized = normalizeNickname(name);
            if (normalized) {
              knownPublishers.add(normalized);
            }
          }
        }

        if (desiredFocus && !knownPublishers.has(desiredFocus)) {
          desiredFocus = null;
        }

        syncSessions();
      }

      function handleFocusUpdate(name) {
        const normalized = normalizeNickname(name);
        if (normalized === desiredFocus) {
          return;
        }

        desiredFocus = normalized;
        updateDisplay();
      }

      function handleMessage(event) {
        let payload;

        try {
          payload = JSON.parse(event.data);
        } catch (error) {
          return;
        }

        switch (payload.type) {
          case "WELCOME":
            handleActivePublishers(payload.publishers);
            handleFocusUpdate(payload.currentFocus);
            break;
          case "STATE_UPDATE":
            handleFocusUpdate(payload.currentFocus);
            break;
          case "VIEWER_REGISTERED":
            viewerRegistered = true;
            syncSessions();
            break;
          case "ACTIVE_PUBLISHERS":
            handleActivePublishers(payload.publishers);
            break;
          case "SIGNAL_PUBLISHER_ANSWER":
            handlePublisherAnswer(payload);
            break;
          case "SIGNAL_PUBLISHER_CANDIDATE":
            handlePublisherCandidate(payload);
            break;
          case "STREAM_UNAVAILABLE":
          case "STREAM_ENDED":
            handleStreamUnavailable(payload);
            break;
          default:
            break;
        }
      }

      function connectWebSocket() {
        if (ws) {
          try {
            ws.close();
          } catch (error) {
            // ignore
          }
        }

        ws = new WebSocket(wsUrl);

        ws.addEventListener("open", () => {
          wsReady = true;
          viewerRegistered = false;
          sendSignal({ type: "HELLO", role: "viewer" });
          syncSessions();
        });

        ws.addEventListener("message", handleMessage);

        ws.addEventListener("close", () => {
          wsReady = false;
          viewerRegistered = false;
          knownPublishers.clear();
          cleanupAllSessions({ notify: false });
          setDisplay(null, null);

          if (reconnectTimer) {
            return;
          }
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connectWebSocket();
          }, 2000);
        });

        ws.addEventListener("error", () => {
          ws.close();
        });
      }

      connectWebSocket();

      window.addEventListener("beforeunload", () => {
        cleanupAllSessions({ notify: true });
      });
    });
  </script>
</body>
</html>
