<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Current Focus Feed</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
    }

    .feed-stack {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .feed-layer {
      position: absolute;
      inset: 0;
      width: 0;
      height: 0;
      object-fit: cover;
      background: transparent;
      display: none;
    }
  </style>
  <script src="js/webrtc-support.js"></script>
</head>
<body>
  <div class="stage">
    <div class="feed-stack">
      <video id="feedA" class="feed-layer" autoplay playsinline muted></video>
      <video id="feedB" class="feed-layer" autoplay playsinline muted></video>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const feedStack = document.querySelector(".feed-stack");
      const videoLayers = Array.from(feedStack?.querySelectorAll(".feed-layer") || []);

      while (feedStack && videoLayers.length < 2) {
        const layer = document.createElement("video");
        layer.autoplay = true;
        layer.playsInline = true;
        layer.muted = true;
        layer.className = "feed-layer";
        feedStack.appendChild(layer);
        videoLayers.push(layer);
      }

      if (!feedStack || videoLayers.length < 2) {
        console.error("Unable to initialize video layers for the focus page.");
        return;
      }

      const fallbackLayer = document.createElement("img");
      fallbackLayer.className = "feed-layer";
      fallbackLayer.style.display = "none";
      fallbackLayer.alt = "Fallback feed";
      fallbackLayer.loading = "lazy";
      fallbackLayer.decoding = "async";
      feedStack.appendChild(fallbackLayer);

      fallbackLayer.addEventListener("error", () => {
        const nickname = fallbackLayer.dataset.nickname;
        if (!nickname) {
          return;
        }
        setTimeout(() => {
          const url = window.WebRTC_SUPPORT?.createMjpegUrl?.(nickname) || `/fallback/mjpeg/${encodeURIComponent(nickname)}?t=${Date.now()}`;
          fallbackLayer.src = url;
        }, 1000);
      });
      const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      const defaultIceServers = [{ urls: "stun:stun.l.google.com:19302" }];
      let resolvedConfig = { iceServers: defaultIceServers, fallback: {} };

      try {
        const config = await (window.WebRTC_SUPPORT?.getConfig?.() ?? Promise.resolve(resolvedConfig));
        if (config && typeof config === "object") {
          resolvedConfig = config;
        }
      } catch (error) {
        resolvedConfig = { iceServers: defaultIceServers, fallback: {} };
      }

      const ICE_SERVERS = Array.isArray(resolvedConfig.iceServers) && resolvedConfig.iceServers.length ? resolvedConfig.iceServers : defaultIceServers;
      const fallbackSettings = resolvedConfig.fallback && typeof resolvedConfig.fallback === "object" ? resolvedConfig.fallback : {};
  const params = new URLSearchParams(window.location.search || "");
  const preferFallback = params.get("fallback") === "mjpeg";
  const userAgent = (navigator.userAgent || "").toLowerCase();
  const forceFallback = preferFallback;
  const hasWebRTC = forceFallback ? false : window.WebRTC_SUPPORT?.hasWebRTCSupport?.() ?? typeof window.RTCPeerConnection === "function";

      let ws;
      let wsReady = false;
      let viewerRegistered = false;
      let reconnectTimer = null;
      let connectionCounter = 0;

      const knownPublishers = new Set();
      const sessions = new Map();
  const retryCounts = new Map();
  const fallbackNicknames = new Set();

      let desiredFocus = null;
  let displayedStream = null;
  let displayedNickname = null;
  let activeVideoIndex = 0;
  let swapToken = 0;

      function normalizeNickname(name) {
        if (typeof name !== "string") {
          return null;
        }
        const trimmed = name.trim();
        return trimmed.length ? trimmed : null;
      }

      function createConnectionId() {
        connectionCounter += 1;
        return `viewer-${Date.now()}-${connectionCounter}`;
      }

      function playVideoSafe(video) {
        const attempt = video.play?.();
        if (!attempt || typeof attempt.then !== "function") {
          return Promise.resolve();
        }
        return attempt.catch(() => {});
      }

      function waitForFirstFrame(video) {
        if (video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA && video.currentTime > 0) {
          return Promise.resolve();
        }

        return new Promise((resolve) => {
          let frameHandle = null;

          const cleanup = () => {
            video.removeEventListener("playing", onPlaying);
            video.removeEventListener("timeupdate", onTimeUpdate);
            if (frameHandle !== null && typeof video.cancelVideoFrameCallback === "function") {
              video.cancelVideoFrameCallback(frameHandle);
            }
          };

          const finish = () => {
            cleanup();
            resolve();
          };

          const onPlaying = () => {
            finish();
          };

          const onTimeUpdate = () => {
            if (video.currentTime > 0) {
              finish();
            }
          };

          video.addEventListener("playing", onPlaying, { once: true });
          video.addEventListener("timeupdate", onTimeUpdate);

          if (typeof video.requestVideoFrameCallback === "function") {
            frameHandle = video.requestVideoFrameCallback(() => {
              finish();
            });
          }
        });
      }

      function ensureLayerVisible(element) {
        if (!element) {
          return;
        }
        element.style.display = "block";
        element.style.width = "100vw";
        element.style.height = "100vh";
        element.style.objectFit = "cover";
        if (!element.style.zIndex) {
          element.style.zIndex = "1";
        }
      }

      function ensureVideoVisible(video) {
        ensureLayerVisible(video);
      }

      function showFallback(nickname) {
        if (!fallbackSettings.mjpeg || !nickname) {
          return;
        }

        const url = window.WebRTC_SUPPORT?.createMjpegUrl?.(nickname) || `/fallback/mjpeg/${encodeURIComponent(nickname)}?t=${Date.now()}`;
        fallbackLayer.dataset.nickname = nickname;
        fallbackLayer.src = url;
        ensureLayerVisible(fallbackLayer);
        fallbackLayer.style.zIndex = "3";

        for (const video of videoLayers) {
          video.style.display = "none";
        }

        displayedStream = null;
        displayedNickname = nickname;
      }

      function hideFallback(nickname) {
        if (nickname && fallbackLayer.dataset.nickname && fallbackLayer.dataset.nickname !== nickname) {
          return;
        }

        fallbackLayer.style.display = "none";
        fallbackLayer.dataset.nickname = "";
        if (fallbackLayer.src) {
          fallbackLayer.removeAttribute("src");
        }
      }

      function activateFallback(nickname) {
        if (!fallbackSettings.mjpeg || !nickname) {
          return;
        }
        fallbackNicknames.add(nickname);
        if (desiredFocus === nickname) {
          showFallback(nickname);
        }
      }

      function deactivateFallback(nickname) {
        if (!nickname) {
          return;
        }
        fallbackNicknames.delete(nickname);
        if (fallbackLayer.dataset.nickname === nickname) {
          hideFallback(nickname);
        }
      }

      function hideVideoLayer(video) {
        if (!video) {
          return;
        }
        video.pause?.();
        video.srcObject = null;
        video.style.display = "none";
        video.style.width = "0";
        video.style.height = "0";
        video.style.zIndex = "0";
      }

      function setDisplay(stream, nickname) {
        const nextStream = stream || null;

        if (nextStream) {
          hideFallback();
        }

        if (!nextStream) {
          swapToken += 1;
          displayedStream = null;
          displayedNickname = null;
          activeVideoIndex = 0;
          for (const layer of videoLayers) {
            hideVideoLayer(layer);
          }
          return;
        }

        if (displayedStream === nextStream) {
          displayedNickname = nickname || displayedNickname;
          ensureVideoVisible(videoLayers[activeVideoIndex]);
          const activeLayer = videoLayers[activeVideoIndex];
          if (activeLayer) {
            activeLayer.style.zIndex = "2";
          }
          return;
        }

        const targetIndex = displayedStream ? (activeVideoIndex === 0 ? 1 : 0) : activeVideoIndex;
        const targetVideo = videoLayers[targetIndex];
        const previousVideo = videoLayers[activeVideoIndex];
        const currentToken = ++swapToken;

        if (displayedStream) {
          ensureVideoVisible(previousVideo);
          previousVideo.style.zIndex = "2";
        }
        ensureVideoVisible(targetVideo);
        targetVideo.style.zIndex = displayedStream ? "1" : "2";
        if (targetVideo.srcObject !== nextStream) {
          targetVideo.srcObject = nextStream;
        }

        playVideoSafe(targetVideo)
          .then(() => waitForFirstFrame(targetVideo))
          .then(() => {
            if (currentToken !== swapToken) {
              return;
            }

            const otherIndex = targetIndex === 0 ? 1 : 0;
            const otherVideo = videoLayers[otherIndex];
            if (otherVideo !== targetVideo) {
              hideVideoLayer(otherVideo);
            }

            targetVideo.style.zIndex = "2";

            displayedStream = nextStream;
            displayedNickname = nickname || null;
            activeVideoIndex = targetIndex;
          })
          .catch((error) => {
            console.error("Failed to render stream", error);
          });
      }

      function updateDisplay() {
        if (!desiredFocus) {
          hideFallback();
          if (displayedStream) {
            setDisplay(null, null);
          }
          return;
        }

        const session = sessions.get(desiredFocus);

        if (session?.stream) {
          deactivateFallback(desiredFocus);
          if (displayedStream !== session.stream) {
            setDisplay(session.stream, session.nickname);
          }
          return;
        }

        if (fallbackNicknames.has(desiredFocus)) {
          showFallback(desiredFocus);
          return;
        }

        hideFallback(desiredFocus);

        if (!sessions.has(desiredFocus)) {
          if (displayedStream) {
            setDisplay(null, null);
          }
          return;
        }
      }

      function sendSignal(payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(payload));
        }
      }

      function cleanupSession(nickname, { notify = true, retainFallback = false } = {}) {
        const session = sessions.get(nickname);
        if (!session) {
          return;
        }

        if (session.connectTimer) {
          clearTimeout(session.connectTimer);
          session.connectTimer = null;
        }

        sessions.delete(nickname);

        if (notify && wsReady) {
          sendSignal({
            type: "VIEWER_STOP",
            nickname,
            connectionId: session.connectionId,
          });
        }

        try {
          session.pc.ontrack = null;
          session.pc.onicecandidate = null;
          session.pc.onconnectionstatechange = null;
          session.pc.close();
        } catch (error) {
          console.warn("Failed to close peer", error);
        }

        if (session.stream) {
          session.stream.getTracks().forEach((track) => track.stop());
        }

        if (!retainFallback) {
          retryCounts.delete(nickname);
          deactivateFallback(nickname);
        } else {
          fallbackNicknames.add(nickname);
        }

        if (displayedNickname === nickname) {
          setDisplay(null, null);
        }
      }

      function cleanupAllSessions({ notify = false } = {}) {
        for (const nickname of Array.from(sessions.keys())) {
          cleanupSession(nickname, { notify, retainFallback: false });
        }
      }

      function restartSession(nickname, { failed = false } = {}) {
        if (!nickname) {
          return;
        }

        if (!knownPublishers.has(nickname)) {
          cleanupSession(nickname, { notify: true, retainFallback: false });
          retryCounts.delete(nickname);
          deactivateFallback(nickname);
          return;
        }

        const retainFallback = failed && fallbackSettings.mjpeg;
        cleanupSession(nickname, { notify: true, retainFallback });

        let attempts = retryCounts.get(nickname) || 0;

        if (failed) {
          attempts += 1;
          retryCounts.set(nickname, attempts);
          if (fallbackSettings.mjpeg) {
            activateFallback(nickname);
          }
        } else {
          attempts = 0;
          retryCounts.set(nickname, 0);
          deactivateFallback(nickname);
        }

        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (!hasWebRTC) {
          activateFallback(nickname);
          return;
        }

        const retryDelay = failed ? Math.min(2000, 400 + attempts * 400) : 200;

        setTimeout(() => {
          startSession(nickname);
        }, retryDelay);
      }

      async function startSession(nickname) {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (!knownPublishers.has(nickname)) {
          return;
        }

        if (sessions.has(nickname)) {
          return;
        }

        if (!hasWebRTC) {
          activateFallback(nickname);
          return;
        }

        const connectionId = createConnectionId();
        const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        const session = { nickname, connectionId, pc, stream: null, connectTimer: null };
        sessions.set(nickname, session);

        if (fallbackSettings.mjpeg) {
          activateFallback(nickname);
        }

        const attempts = retryCounts.get(nickname) || 0;
        const connectTimeout = Math.min(8000, 4000 + attempts * 500);
        session.connectTimer = setTimeout(() => {
          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            return;
          }
          restartSession(nickname, { failed: true });
        }, connectTimeout);

        pc.ontrack = (event) => {
          const [stream] = event.streams || [];
          if (!stream) {
            return;
          }

          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            stream.getTracks().forEach((track) => track.stop());
            return;
          }

          if (current.connectTimer) {
            clearTimeout(current.connectTimer);
            current.connectTimer = null;
          }

          retryCounts.set(nickname, 0);
          deactivateFallback(nickname);

          current.stream = stream;
          if (desiredFocus === nickname) {
            setDisplay(stream, nickname);
          }
        };

        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            return;
          }
          sendSignal({
            type: "VIEWER_ICE",
            nickname,
            connectionId,
            candidate: event.candidate,
          });
        };

        pc.onconnectionstatechange = () => {
          const current = sessions.get(nickname);
          if (!current || current.connectionId !== connectionId) {
            return;
          }

          if (pc.connectionState === "connected") {
            if (current.connectTimer) {
              clearTimeout(current.connectTimer);
              current.connectTimer = null;
            }
            retryCounts.set(nickname, 0);
            deactivateFallback(nickname);
            return;
          }

          if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
            if (current.connectTimer) {
              clearTimeout(current.connectTimer);
              current.connectTimer = null;
            }
            restartSession(nickname, { failed: true });
          } else if (pc.connectionState === "closed") {
            cleanupSession(nickname, { notify: false });
          }
        };

        try {
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);

          sendSignal({
            type: "VIEWER_OFFER",
            nickname,
            connectionId,
            sdp: pc.localDescription,
          });
        } catch (error) {
          if (session.connectTimer) {
            clearTimeout(session.connectTimer);
            session.connectTimer = null;
          }
      console.error("Failed to start WebRTC session", error);
          restartSession(nickname, { failed: true });
        }
      }

      function syncSessions() {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        for (const nickname of knownPublishers) {
          if (!sessions.has(nickname)) {
            startSession(nickname);
          }
        }

        for (const nickname of Array.from(sessions.keys())) {
          if (!knownPublishers.has(nickname)) {
            cleanupSession(nickname, { notify: true });
          }
        }

        updateDisplay();
      }

      function handlePublisherAnswer(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        session.pc.setRemoteDescription(payload.sdp).catch((error) => {
      console.error("Failed to apply answer", error);
          restartSession(nickname, { failed: true });
        });
      }

      async function handlePublisherCandidate(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        try {
          await session.pc.addIceCandidate(payload.candidate || null);
        } catch (error) {
      console.error("ICE candidate error", error);
        }
      }

      function handleStreamUnavailable(payload) {
        const nickname = normalizeNickname(payload.nickname);
        if (!nickname) {
          return;
        }

        const session = sessions.get(nickname);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        restartSession(nickname, { failed: true });
      }

      function handleActivePublishers(list) {
        knownPublishers.clear();

        if (Array.isArray(list)) {
          for (const name of list) {
            const normalized = normalizeNickname(name);
            if (normalized) {
              knownPublishers.add(normalized);
            }
          }
        }

        if (desiredFocus && !knownPublishers.has(desiredFocus)) {
          desiredFocus = null;
        }

        syncSessions();
      }

      function handleFocusUpdate(name) {
        const normalized = normalizeNickname(name);
        if (normalized === desiredFocus) {
          return;
        }

        desiredFocus = normalized;
        updateDisplay();
      }

      function handleMessage(event) {
        let payload;

        try {
          payload = JSON.parse(event.data);
        } catch (error) {
          return;
        }

        switch (payload.type) {
          case "WELCOME":
            handleActivePublishers(payload.publishers);
            handleFocusUpdate(payload.currentFocus);
            break;
          case "STATE_UPDATE":
            handleFocusUpdate(payload.currentFocus);
            break;
          case "VIEWER_REGISTERED":
            viewerRegistered = true;
            syncSessions();
            break;
          case "ACTIVE_PUBLISHERS":
            handleActivePublishers(payload.publishers);
            break;
          case "SIGNAL_PUBLISHER_ANSWER":
            handlePublisherAnswer(payload);
            break;
          case "SIGNAL_PUBLISHER_CANDIDATE":
            handlePublisherCandidate(payload);
            break;
          case "STREAM_UNAVAILABLE":
          case "STREAM_ENDED":
            handleStreamUnavailable(payload);
            break;
          default:
            break;
        }
      }

      function connectWebSocket() {
        if (ws) {
          try {
            ws.close();
          } catch (error) {
            // ignore
          }
        }

        ws = new WebSocket(wsUrl);

        ws.addEventListener("open", () => {
          wsReady = true;
          viewerRegistered = false;
          sendSignal({ type: "HELLO", role: "viewer" });
          syncSessions();
        });

        ws.addEventListener("message", handleMessage);

        ws.addEventListener("close", () => {
          wsReady = false;
          viewerRegistered = false;
          knownPublishers.clear();
          cleanupAllSessions({ notify: false });
          setDisplay(null, null);

          if (reconnectTimer) {
            return;
          }
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connectWebSocket();
          }, 2000);
        });

        ws.addEventListener("error", () => {
          ws.close();
        });
      }

      connectWebSocket();

      window.addEventListener("beforeunload", () => {
        cleanupAllSessions({ notify: true });
      });
    });
  </script>
</body>
</html>
