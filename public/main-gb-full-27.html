<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Current Focus Feed</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: transparent;
      overflow: hidden;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
    }

    .feed-stack {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .feed-layer {
      position: absolute;
      inset: 0;
      width: 0;
      height: 0;
      object-fit: cover;
      background: transparent;
      display: none;
    }
  </style>
</head>
<body>
  <div class="stage">
    <div class="feed-stack">
      <video id="feedA" class="feed-layer" autoplay playsinline muted></video>
      <video id="feedB" class="feed-layer" autoplay playsinline muted></video>
    </div>
  </div>

  <script type="module">
    import { API_BASE, WS_BASE, LOGO_DB_PROXY } from "./js/endpoints.js";
    window.API_BASE = API_BASE;
    window.WS_BASE = WS_BASE;
    window.LOGO_DB_PROXY = LOGO_DB_PROXY;
    console.log("[BOOT] API_BASE=", API_BASE, "WS_BASE=", WS_BASE, "LOGO_DB_PROXY=", LOGO_DB_PROXY);
  </script>

  <script type="module">
    // Updated for TURN server integration
    import { getConfig, hasWebRTCSupport, createMjpegUrl } from "./js/webrtc-support.js";
    document.addEventListener("DOMContentLoaded", async () => {
      const feedStack = document.querySelector(".feed-stack");
      const videoLayers = Array.from(feedStack?.querySelectorAll(".feed-layer") || []);

      while (feedStack && videoLayers.length < 2) {
        const layer = document.createElement("video");
        layer.autoplay = true;
        layer.playsInline = true;
        layer.muted = true;
        layer.className = "feed-layer";
        feedStack.appendChild(layer);
        videoLayers.push(layer);
      }

      if (!feedStack || videoLayers.length < 2) {
        console.error("Unable to initialize video layers for the focus page.");
        return;
      }

      const fallbackLayer = document.createElement("img");
      fallbackLayer.className = "feed-layer";
      fallbackLayer.style.display = "none";
      fallbackLayer.alt = "Fallback feed";
      fallbackLayer.loading = "lazy";
      fallbackLayer.decoding = "async";
      feedStack.appendChild(fallbackLayer);

      fallbackLayer.addEventListener("error", () => {
        const nickname = fallbackLayer.dataset.nickname;
        if (!nickname) {
          return;
        }
        setTimeout(() => {
          fallbackLayer.src = createMjpegUrl(nickname);
        }, 1000);
      });
  const wsUrl = window.WS_BASE;
      let resolvedConfig = await getConfig();
      if (!resolvedConfig || typeof resolvedConfig !== "object") {
        resolvedConfig = { iceServers: [], fallback: {} };
      }
      console.log("[ICE] using TURN", resolvedConfig.iceServers);

      const fallbackSettings = resolvedConfig.fallback && typeof resolvedConfig.fallback === "object" ? resolvedConfig.fallback : {};
  const params = new URLSearchParams(window.location.search || "");
  const FORCE_RELAY = params.get("relay") === "1";
  const preferFallback = params.get("fallback") === "mjpeg";
  const userAgent = (navigator.userAgent || "").toLowerCase();
  const forceFallback = preferFallback;
  const hasWebRTC = forceFallback ? false : hasWebRTCSupport();

      let ws;
      let wsReady = false;
      let viewerRegistered = false;
      let reconnectTimer = null;
      let connectionCounter = 0;

    const knownPublishers = new Map();
    const sessions = new Map();
  const retryCounts = new Map();
  const fallbackNicknames = new Set();
  const forcedFallbackOverrides = new Set();
  let fallbackTimer = null;
  let fallbackTimerKey = null;

  let desiredFocusKey = null;
  let desiredFocusDisplay = null;
  let displayedStream = null;
  let displayedNickname = null;
  let displayedNicknameKey = null;
  let activeVideoIndex = 0;
  let swapToken = 0;

      function normalizeNickname(name) {
        if (typeof name !== "string") {
          return null;
        }
        const trimmed = name.trim();
        if (!trimmed) {
          return null;
        }
        return trimmed.replace(/\s+/g, " ");
      }

      function nicknameKey(name) {
        const normalized = normalizeNickname(name);
        if (!normalized) {
          return null;
        }
        return normalized.replace(/\s+/g, "").toLowerCase();
      }

      function createConnectionId() {
        connectionCounter += 1;
        return `viewer-${Date.now()}-${connectionCounter}`;
      }

      function playVideoSafe(video) {
        const attempt = video.play?.();
        if (!attempt || typeof attempt.then !== "function") {
          return Promise.resolve();
        }
        return attempt.catch(() => {});
      }

      function waitForFirstFrame(video) {
        if (video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA && video.currentTime > 0) {
          return Promise.resolve();
        }

        return new Promise((resolve) => {
          let frameHandle = null;

          const cleanup = () => {
            video.removeEventListener("playing", onPlaying);
            video.removeEventListener("timeupdate", onTimeUpdate);
            if (frameHandle !== null && typeof video.cancelVideoFrameCallback === "function") {
              video.cancelVideoFrameCallback(frameHandle);
            }
          };

          const finish = () => {
            cleanup();
            resolve();
          };

          const onPlaying = () => {
            finish();
          };

          const onTimeUpdate = () => {
            if (video.currentTime > 0) {
              finish();
            }
          };

          video.addEventListener("playing", onPlaying, { once: true });
          video.addEventListener("timeupdate", onTimeUpdate);

          if (typeof video.requestVideoFrameCallback === "function") {
            frameHandle = video.requestVideoFrameCallback(() => {
              finish();
            });
          }
        });
      }

      function ensureLayerVisible(element) {
        if (!element) {
          return;
        }
        element.style.display = "block";
        element.style.width = "100vw";
        element.style.height = "100vh";
        element.style.objectFit = "cover";
        if (!element.style.zIndex) {
          element.style.zIndex = "1";
        }
      }

      function ensureVideoVisible(video) {
        ensureLayerVisible(video);
      }

      function showFallback(nickname) {
        if (!fallbackSettings.mjpeg) {
          return;
        }

        const normalized = normalizeNickname(nickname);
        const key = nicknameKey(normalized);
        if (!normalized || !key) {
          return;
        }

        const url =
          createMjpegUrl(normalized);
        fallbackLayer.dataset.nickname = normalized;
        fallbackLayer.dataset.nicknameKey = key;
        fallbackLayer.src = url;
        ensureLayerVisible(fallbackLayer);
        fallbackLayer.style.zIndex = "3";

        for (const video of videoLayers) {
          video.style.display = "none";
        }

        displayedStream = null;
        displayedNickname = normalized;
        displayedNicknameKey = key;
      }

      function hideFallback(nickname) {
        if (nickname) {
          const key = nicknameKey(nickname);
          if (key && fallbackLayer.dataset.nicknameKey && fallbackLayer.dataset.nicknameKey !== key) {
            return;
          }
        }

        fallbackLayer.style.display = "none";
        fallbackLayer.dataset.nickname = "";
        fallbackLayer.dataset.nicknameKey = "";
        if (fallbackLayer.src) {
          fallbackLayer.removeAttribute("src");
        }
      }

      function scheduleFallback(nickname) {
        if (!fallbackSettings.mjpeg) {
          return;
        }

        const normalized = normalizeNickname(nickname);
        const key = nicknameKey(normalized);
        if (!normalized || !key) {
          return;
        }

        if (fallbackLayer.dataset.nicknameKey === key && fallbackLayer.style.display === "block") {
          return;
        }

        if (fallbackTimer && fallbackTimerKey === key) {
          return;
        }

        clearTimeout(fallbackTimer);
        fallbackTimerKey = key;
        fallbackTimer = setTimeout(() => {
          fallbackTimer = null;
          fallbackTimerKey = null;
          showFallback(normalized);
        }, 2500);
      }

      function cancelFallback(nickname) {
        const key = nicknameKey(nickname);
        if (fallbackTimer && (!key || fallbackTimerKey === key)) {
          clearTimeout(fallbackTimer);
          fallbackTimer = null;
          fallbackTimerKey = null;
        }
        deactivateFallback(nickname);
      }

      function activateFallback(nickname) {
        if (!fallbackSettings.mjpeg) {
          return;
        }
        const normalized = normalizeNickname(nickname);
        const key = nicknameKey(normalized);
        if (!key || !normalized) {
          return;
        }
        fallbackNicknames.add(key);
        if (desiredFocusKey === key) {
          scheduleFallback(normalized);
        }
      }

      function deactivateFallback(nickname) {
        const key = nicknameKey(nickname);
        if (!key) {
          return;
        }
        fallbackNicknames.delete(key);
        if (fallbackLayer.dataset.nicknameKey === key) {
          hideFallback(fallbackLayer.dataset.nickname);
        }
        if (fallbackTimer && fallbackTimerKey === key) {
          clearTimeout(fallbackTimer);
          fallbackTimer = null;
          fallbackTimerKey = null;
        }
      }

      function applyForcedFallbackList(list) {
        const updated = new Set();
        if (Array.isArray(list)) {
          for (const value of list) {
            const key = nicknameKey(value);
            if (key) {
              updated.add(key);
            }
          }
        }

        let changed = false;
        if (updated.size !== forcedFallbackOverrides.size) {
          changed = true;
        } else {
          for (const key of forcedFallbackOverrides) {
            if (!updated.has(key)) {
              changed = true;
              break;
            }
          }
        }

        if (!changed) {
          return;
        }

        const affected = new Set();
        for (const key of forcedFallbackOverrides) {
          affected.add(key);
        }
        for (const key of updated) {
          affected.add(key);
        }

        forcedFallbackOverrides.clear();
        for (const key of updated) {
          forcedFallbackOverrides.add(key);
        }

        for (const [sessionKey, session] of sessions.entries()) {
          if (affected.has(sessionKey)) {
            restartSession(session.nickname, { failed: true });
          }
        }

        syncSessions();
      }

      function hasForcedFallback(nickname) {
        const key = nicknameKey(nickname);
        if (!key) {
          return false;
        }
        return forcedFallbackOverrides.has(key);
      }

      function hideVideoLayer(video) {
        if (!video) {
          return;
        }
        video.pause?.();
        video.srcObject = null;
        video.style.display = "none";
        video.style.width = "0";
        video.style.height = "0";
        video.style.zIndex = "0";
      }

      function setDisplay(stream, nickname) {
        const nextStream = stream || null;

        if (nextStream) {
          hideFallback();
        }

        if (!nextStream) {
          swapToken += 1;
          displayedStream = null;
          displayedNickname = null;
          displayedNicknameKey = null;
          activeVideoIndex = 0;
          for (const layer of videoLayers) {
            hideVideoLayer(layer);
          }
          return;
        }

        if (displayedStream === nextStream) {
          if (nickname) {
            displayedNickname = normalizeNickname(nickname) || displayedNickname;
            displayedNicknameKey = nicknameKey(displayedNickname) || displayedNicknameKey;
          }
          ensureVideoVisible(videoLayers[activeVideoIndex]);
          const activeLayer = videoLayers[activeVideoIndex];
          if (activeLayer) {
            activeLayer.style.zIndex = "2";
          }
          return;
        }

        const targetIndex = displayedStream ? (activeVideoIndex === 0 ? 1 : 0) : activeVideoIndex;
        const targetVideo = videoLayers[targetIndex];
        const previousVideo = videoLayers[activeVideoIndex];
        const currentToken = ++swapToken;

        if (displayedStream) {
          ensureVideoVisible(previousVideo);
          previousVideo.style.zIndex = "2";
        }
        ensureVideoVisible(targetVideo);
        targetVideo.style.zIndex = displayedStream ? "1" : "2";
        if (targetVideo.srcObject !== nextStream) {
          targetVideo.srcObject = nextStream;
        }

        playVideoSafe(targetVideo)
          .then(() => waitForFirstFrame(targetVideo))
          .then(() => {
            if (currentToken !== swapToken) {
              return;
            }

            const otherIndex = targetIndex === 0 ? 1 : 0;
            const otherVideo = videoLayers[otherIndex];
            if (otherVideo !== targetVideo) {
              hideVideoLayer(otherVideo);
            }

            targetVideo.style.zIndex = "2";

            displayedStream = nextStream;
            displayedNickname = normalizeNickname(nickname) || null;
            displayedNicknameKey = nicknameKey(displayedNickname);
            activeVideoIndex = targetIndex;
          })
          .catch((error) => {
            console.error("Failed to render stream", error);
          });
      }

      function updateDisplay() {
        if (!desiredFocusKey) {
          hideFallback();
          if (displayedStream) {
            setDisplay(null, null);
          }
          return;
        }

        const session = sessions.get(desiredFocusKey) || null;
        const hasStream = Boolean(session && session.stream);
        const fallbackTarget = desiredFocusDisplay || session?.nickname || "";

        if (hasStream) {
          cancelFallback(session.nickname);
          if (displayedStream !== session.stream) {
            setDisplay(session.stream, session.nickname);
          }
          return;
        }

        if (displayedStream) {
          setDisplay(null, null);
        }

        if (fallbackNicknames.has(desiredFocusKey)) {
          if (
            fallbackLayer.dataset.nicknameKey === desiredFocusKey &&
            fallbackLayer.style.display === "block"
          ) {
            return;
          }
          scheduleFallback(fallbackTarget);
          return;
        }

        hideFallback(fallbackTarget);
      }

      function sendSignal(payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(payload));
        }
      }

      function cleanupSession(nickname, { notify = true, retainFallback = false } = {}) {
        const normalized = normalizeNickname(nickname);
        const key = nicknameKey(normalized);
        const session = key ? sessions.get(key) : null;
        if (!session) {
          return;
        }

        if (session.connectTimer) {
          clearTimeout(session.connectTimer);
          session.connectTimer = null;
        }

        sessions.delete(key);

        if (notify && wsReady) {
          sendSignal({
            type: "VIEWER_STOP",
            nickname: session.nickname,
            connectionId: session.connectionId,
          });
        }

        try {
          session.pc.ontrack = null;
          session.pc.onicecandidate = null;
          session.pc.onconnectionstatechange = null;
          session.pc.close();
        } catch (error) {
          console.warn("Failed to close peer", error);
        }

        if (session.stream) {
          session.stream.getTracks().forEach((track) => track.stop());
        }

        if (!retainFallback) {
          retryCounts.delete(key);
          cancelFallback(session.nickname);
        } else {
          fallbackNicknames.add(key);
        }

        if (displayedNicknameKey === key) {
          setDisplay(null, null);
        }
      }

      function cleanupAllSessions({ notify = false } = {}) {
        for (const session of Array.from(sessions.values())) {
          cleanupSession(session.nickname, { notify, retainFallback: false });
        }
      }

      function restartSession(nickname, { failed = false } = {}) {
        const normalized = normalizeNickname(nickname);
        const key = nicknameKey(normalized);
        if (!key || !normalized) {
          return;
        }

        if (!knownPublishers.has(key)) {
          cleanupSession(normalized, { notify: true, retainFallback: false });
          retryCounts.delete(key);
          cancelFallback(normalized);
          return;
        }

        const retainFallback = failed && fallbackSettings.mjpeg;
        cleanupSession(normalized, { notify: true, retainFallback });

        let attempts = retryCounts.get(key) || 0;

        if (failed) {
          attempts += 1;
          retryCounts.set(key, attempts);
          if (fallbackSettings.mjpeg) {
            activateFallback(normalized);
          }
        } else {
          attempts = 0;
          retryCounts.set(key, 0);
          cancelFallback(normalized);
        }

        if (!viewerRegistered || !wsReady) {
          return;
        }

        if (!hasWebRTC || hasForcedFallback(normalized)) {
          activateFallback(normalized);
          return;
        }

        const retryDelay = failed ? Math.min(2000, 400 + attempts * 400) : 200;

        setTimeout(() => {
          startSession(normalized);
        }, retryDelay);
      }

      async function startSession(nickname) {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        const normalized = normalizeNickname(nickname);
        const key = nicknameKey(normalized);
        if (!normalized || !key) {
          return;
        }

        if (!knownPublishers.has(key)) {
          return;
        }

        if (sessions.has(key)) {
          return;
        }

        if (!hasWebRTC) {
          activateFallback(normalized);
          return;
        }

        const connectionId = createConnectionId();
  const pc = await (await import("./js/webrtc-support.js")).createPeerConnection(FORCE_RELAY);
        const session = {
          key,
          nickname: normalized,
          connectionId,
          pc,
          stream: null,
          connectTimer: null,
        };
        sessions.set(key, session);

        if (fallbackSettings.mjpeg) {
          activateFallback(normalized);
        }

        const attempts = retryCounts.get(key) || 0;
        const connectTimeout = Math.min(8000, 4000 + attempts * 500);
        session.connectTimer = setTimeout(() => {
          const current = sessions.get(key);
          if (!current || current.connectionId !== connectionId) {
            return;
          }
          restartSession(normalized, { failed: true });
        }, connectTimeout);

        pc.ontrack = (event) => {
          const [stream] = event.streams || [];
          if (!stream) {
            return;
          }

          const current = sessions.get(key);
          if (!current || current.connectionId !== connectionId) {
            stream.getTracks().forEach((track) => track.stop());
            return;
          }

          if (current.connectTimer) {
            clearTimeout(current.connectTimer);
            current.connectTimer = null;
          }

          retryCounts.set(key, 0);
          cancelFallback(current.nickname);

          current.stream = stream;
          if (desiredFocusKey === key) {
            setDisplay(stream, current.nickname);
          }
        };

        pc.onicecandidate = (event) => {
          if (!event.candidate) {
            return;
          }
          sendSignal({
            type: "VIEWER_ICE",
            nickname: normalized,
            connectionId,
            candidate: event.candidate,
          });
        };

        pc.onconnectionstatechange = () => {
          const current = sessions.get(key);
          if (!current || current.connectionId !== connectionId) {
            return;
          }

          if (pc.connectionState === "connected") {
            if (current.connectTimer) {
              clearTimeout(current.connectTimer);
              current.connectTimer = null;
            }
            retryCounts.set(key, 0);
            cancelFallback(current.nickname);
            return;
          }

          if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
            if (current.connectTimer) {
              clearTimeout(current.connectTimer);
              current.connectTimer = null;
            }
            restartSession(current.nickname, { failed: true });
          } else if (pc.connectionState === "closed") {
            cleanupSession(current.nickname, { notify: false });
          }
        };

        try {
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);

          sendSignal({
            type: "VIEWER_OFFER",
            nickname: normalized,
            connectionId,
            sdp: pc.localDescription,
          });
        } catch (error) {
          if (session.connectTimer) {
            clearTimeout(session.connectTimer);
            session.connectTimer = null;
          }
          console.error("Failed to start WebRTC session", error);
          restartSession(normalized, { failed: true });
        }
      }

      function syncSessions() {
        if (!viewerRegistered || !wsReady) {
          return;
        }

        for (const [key, display] of knownPublishers.entries()) {
          if (!sessions.has(key)) {
            startSession(display);
          }
        }

        for (const [key, session] of Array.from(sessions.entries())) {
          if (!knownPublishers.has(key)) {
            cleanupSession(session.nickname, { notify: true });
          }
        }

        updateDisplay();
      }

      function handlePublisherAnswer(payload) {
        const nickname = normalizeNickname(payload.nickname);
        const key = nicknameKey(nickname);
        if (!key) {
          return;
        }

        const session = sessions.get(key);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        session.pc.setRemoteDescription(payload.sdp).catch((error) => {
      console.error("Failed to apply answer", error);
          restartSession(session.nickname, { failed: true });
        });
      }

      async function handlePublisherCandidate(payload) {
        const nickname = normalizeNickname(payload.nickname);
        const key = nicknameKey(nickname);
        if (!key) {
          return;
        }

        const session = sessions.get(key);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        try {
          await session.pc.addIceCandidate(payload.candidate || null);
        } catch (error) {
      console.error("ICE candidate error", error);
        }
      }

      function handleStreamUnavailable(payload) {
        const nickname = normalizeNickname(payload.nickname);
        const key = nicknameKey(nickname);
        if (!key) {
          return;
        }

        const session = sessions.get(key);
        if (!session || session.connectionId !== payload.connectionId) {
          return;
        }

        restartSession(session.nickname, { failed: true });
      }

      function handleActivePublishers(list) {
        knownPublishers.clear();

        if (Array.isArray(list)) {
          for (const name of list) {
            const normalized = normalizeNickname(name);
            const key = nicknameKey(normalized);
            if (normalized && key) {
              knownPublishers.set(key, normalized);
              if (desiredFocusKey === key) {
                desiredFocusDisplay = normalized;
              }
            }
          }
        }

        if (desiredFocusKey && !knownPublishers.has(desiredFocusKey)) {
          desiredFocusKey = null;
          desiredFocusDisplay = null;
        }

        syncSessions();
      }

      function handleFocusUpdate(name) {
        const normalized = normalizeNickname(name);
        const key = nicknameKey(normalized);
        if (fallbackTimer && fallbackTimerKey && fallbackTimerKey !== key) {
          clearTimeout(fallbackTimer);
          fallbackTimer = null;
          fallbackTimerKey = null;
        }

        desiredFocusKey = key;
        desiredFocusDisplay = key ? knownPublishers.get(key) || normalized : null;
        updateDisplay();
      }

      function handleMessage(event) {
        let payload;

        try {
          payload = JSON.parse(event.data);
        } catch (error) {
          return;
        }

        switch (payload.type) {
          case "WELCOME":
            handleActivePublishers(payload.publishers);
            handleFocusUpdate(payload.currentFocus);
            applyForcedFallbackList(payload.forcedFallback);
            break;
          case "STATE_UPDATE":
            handleFocusUpdate(payload.currentFocus);
            break;
          case "VIEWER_REGISTERED":
            viewerRegistered = true;
            syncSessions();
            break;
          case "ACTIVE_PUBLISHERS":
            handleActivePublishers(payload.publishers);
            break;
          case "FORCED_FALLBACK":
            applyForcedFallbackList(payload.nicknames);
            break;
          case "SIGNAL_PUBLISHER_ANSWER":
            handlePublisherAnswer(payload);
            break;
          case "SIGNAL_PUBLISHER_CANDIDATE":
            handlePublisherCandidate(payload);
            break;
          case "STREAM_UNAVAILABLE":
          case "STREAM_ENDED":
            handleStreamUnavailable(payload);
            break;
          default:
            break;
        }
      }

      function connectWebSocket() {
        if (ws) {
          try {
            ws.close();
          } catch (error) {
            // ignore
          }
        }

        ws = new WebSocket(wsUrl);

        ws.addEventListener("open", () => {
          wsReady = true;
          viewerRegistered = false;
          console.log("[WS] connected to", window.WS_BASE);
          console.log("[API] target", window.API_BASE);
          sendSignal({ type: "HELLO", role: "viewer" });
          syncSessions();
        });

        ws.addEventListener("message", handleMessage);

        ws.addEventListener("close", () => {
          wsReady = false;
          viewerRegistered = false;
          knownPublishers.clear();
          cleanupAllSessions({ notify: false });
          setDisplay(null, null);

          if (reconnectTimer) {
            return;
          }
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            connectWebSocket();
          }, 2000);
        });

        ws.addEventListener("error", () => {
          ws.close();
        });
      }

      connectWebSocket();

      window.addEventListener("beforeunload", () => {
        cleanupAllSessions({ notify: true });
      });
    });
  </script>
</body>
</html>
