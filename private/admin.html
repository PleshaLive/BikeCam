<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Broadcast Control Center</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0d1424;
      --bg-soft: rgba(16, 23, 40, 0.84);
      --panel: rgba(22, 30, 52, 0.92);
      --panel-strong: rgba(14, 21, 38, 0.92);
      --border: rgba(91, 116, 217, 0.28);
      --accent: #6d8dff;
      --accent-soft: rgba(109, 141, 255, 0.16);
      --text: #f5f7ff;
      --muted: rgba(245, 247, 255, 0.7);
      --danger: #ff6f76;
      --success: #65f5b2;
      --radius-lg: 24px;
      --radius-md: 18px;
      --radius-sm: 12px;
      --shadow-soft: 0 30px 80px rgba(3, 8, 22, 0.6);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 40px 20px 64px;
      font-family: "Inter", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle at 20% 16%, rgba(109, 141, 255, 0.18), transparent 54%),
        radial-gradient(circle at 80% 12%, rgba(101, 245, 178, 0.12), transparent 60%),
        linear-gradient(160deg, #050915, var(--bg) 64%, #050915);
      color: var(--text);
      display: flex;
      justify-content: center;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: linear-gradient(130deg, rgba(109, 141, 255, 0.08), transparent 55%),
        radial-gradient(circle at 16% 72%, rgba(101, 245, 178, 0.08), transparent 60%);
      pointer-events: none;
      z-index: -1;
    }

    .layout {
      width: min(1280px, 100%);
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    header {
      position: relative;
      background: linear-gradient(145deg, rgba(25, 32, 55, 0.94), rgba(15, 21, 36, 0.88));
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 28px 32px 32px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 22px;
    }

    header::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: var(--radius-lg);
      background: linear-gradient(210deg, rgba(109, 141, 255, 0.16), rgba(101, 245, 178, 0.06));
      opacity: 0.45;
      pointer-events: none;
    }

    header > * {
      position: relative;
      z-index: 1;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.7rem, 2.4vw, 2.1rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    #messageBox {
      min-height: 22px;
      font-size: 0.92rem;
      font-weight: 550;
      color: var(--success);
    }

    #messageBox.error {
      color: var(--danger);
    }

    #navLinks {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    #navLinks a {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 999px;
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-decoration: none;
      color: var(--text);
      background: var(--accent-soft);
      border: 1px solid rgba(109, 141, 255, 0.2);
      transition: transform 0.18s ease, background 0.18s ease;
    }

    #navLinks a:hover {
      transform: translateY(-1px);
      background: rgba(109, 141, 255, 0.24);
    }

    .status-board {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 16px;
    }

    .status-card {
      background: rgba(18, 25, 44, 0.92);
      border: 1px solid rgba(109, 141, 255, 0.2);
      border-radius: var(--radius-md);
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-shadow: inset 0 1px 0 rgba(250, 252, 255, 0.04);
    }

    .status-card span {
      font-size: 0.72rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .status-card strong {
      font-size: clamp(1.1rem, 2vw, 1.35rem);
    }

    main {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 24px;
    }

    section {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 18px;
      padding: 24px 24px 28px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      background: linear-gradient(160deg, var(--panel), var(--panel-strong));
      box-shadow: 0 18px 50px rgba(5, 10, 30, 0.55);
      backdrop-filter: blur(12px);
    }

    section::before {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: calc(var(--radius-lg) - 1px);
      background: radial-gradient(circle at 14% 20%, rgba(109, 141, 255, 0.14), transparent 64%);
      pointer-events: none;
      opacity: 0.7;
    }

    section > * {
      position: relative;
      z-index: 1;
    }

    section h2 {
      margin: 0;
      font-size: clamp(1.05rem, 1.8vw, 1.2rem);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .table-wrapper {
      border-radius: var(--radius-md);
      border: 1px solid rgba(109, 141, 255, 0.08);
      background: rgba(10, 15, 28, 0.6);
      overflow: hidden;
      overflow-x: auto;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 520px;
    }

    thead {
      background: rgba(109, 141, 255, 0.12);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.72rem;
      color: var(--muted);
    }

    th,
    td {
      padding: 14px 18px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    tbody tr:hover {
      background: rgba(109, 141, 255, 0.08);
    }

    button {
      padding: 9px 18px;
      border-radius: var(--radius-sm);
      border: 1px solid transparent;
      background: rgba(109, 141, 255, 0.14);
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.18s ease, background 0.18s ease, border 0.18s ease;
    }

    button:hover {
      transform: translateY(-1px);
      background: rgba(109, 141, 255, 0.2);
      border-color: rgba(109, 141, 255, 0.4);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(109, 141, 255, 0.3);
      color: var(--accent);
    }

    button.danger {
      background: rgba(255, 111, 118, 0.14);
      border-color: rgba(255, 111, 118, 0.28);
      color: var(--danger);
    }

    form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      align-items: end;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.75rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }

    input {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(10, 15, 28, 0.64);
      color: var(--text);
      font-size: 0.95rem;
      transition: border 0.18s ease, box-shadow 0.18s ease;
    }

    input:focus {
      outline: none;
      border-color: rgba(109, 141, 255, 0.6);
      box-shadow: 0 0 0 3px rgba(109, 141, 255, 0.16);
    }

    .tag {
      display: inline-flex;
      align-items: center;
      padding: 4px 12px;
      border-radius: 999px;
      background: rgba(109, 141, 255, 0.12);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      margin-left: 8px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(109, 141, 255, 0.2);
      font-size: 0.68rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      box-shadow: 0 0 0 1px rgba(109, 141, 255, 0.18);
    }

    .section-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    @media (max-width: 860px) {
      body {
        padding: 28px 16px 48px;
      }

      main {
        grid-template-columns: 1fr;
      }

      table {
        min-width: 100%;
      }
    }

    @media (max-width: 520px) {
      header {
        padding: 24px;
      }

      section {
        padding: 22px 18px 26px;
      }

      #navLinks a {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="layout">
    <!-- Visibility check: ensuring private assets are tracked in VCS -->
    <header>
    <h1>Broadcast Control Center</h1>
    <div id="messageBox"></div>
    <nav id="navLinks"></nav>
    <div class="status-board">
      <div class="status-card">
        <span>Current Focus</span>
        <strong id="focusName">--</strong>
      </div>
      <div class="status-card">
        <span>Cameras live/total</span>
        <strong id="cameraCount">0</strong>
      </div>
      <div class="status-card">
        <span>Last Sync</span>
        <strong id="updatedAt">--</strong>
      </div>
    </div>
    </header>

    <main>
      <section>
      <h2>Allowed Admin IPs</h2>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>IP Address</th>
                <th>Label</th>
                <th>Added</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="ipTableBody"></tbody>
          </table>
        </div>

        <form id="addIpForm">
          <label for="ipInput">Add new admin IP
            <input id="ipInput" name="ip" type="text" placeholder="203.0.113.5" required>
          </label>
          <label for="labelInput">Label (nickname)
            <input id="labelInput" name="label" type="text" placeholder="Who is this for?">
          </label>
          <button type="submit">Add IP</button>
        </form>
      </section>

      <section>
      <h2>Active Cameras</h2>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Team</th>
                <th>Slot</th>
                <th>Status</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="cameraTableBody"></tbody>
          </table>
        </div>
      </section>

      <section>
      <h2>Server Roster (GSI)</h2>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Player</th>
                <th>Team</th>
                <th>Slot</th>
                <th>Steam ID</th>
              </tr>
            </thead>
            <tbody id="rosterTableBody"></tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    import { API_BASE, WS_BASE, LOGO_DB_PROXY } from "/js/endpoints.js";
    window.API_BASE = API_BASE;
    window.WS_BASE = WS_BASE;
    window.LOGO_DB_PROXY = LOGO_DB_PROXY;
    console.log("[BOOT] API_BASE=%s WS_BASE=%s LOGO_DB_PROXY=%s", API_BASE, WS_BASE, LOGO_DB_PROXY);
  </script>

  <script type="module">
    const DASHBOARD_ENDPOINT = `${window.API_BASE}/api/admin/dashboard`;
    const ADD_IP_ENDPOINT = `${window.API_BASE}/api/admin/allowed-ips`;
    const KICK_ENDPOINT = `${window.API_BASE}/api/admin/kick`;
    const FALLBACK_ENDPOINT = `${window.API_BASE}/api/admin/fallback`;

    let ownerIp = "";
    let forcedFallbackList = [];

    const messageBox = document.getElementById("messageBox");
    const focusName = document.getElementById("focusName");
    const updatedAt = document.getElementById("updatedAt");
    const cameraCount = document.getElementById("cameraCount");
    const navLinks = document.getElementById("navLinks");
    const ipTableBody = document.getElementById("ipTableBody");
    const cameraTableBody = document.getElementById("cameraTableBody");
    const rosterTableBody = document.getElementById("rosterTableBody");

    function setMessage(message, isError = false) {
      messageBox.textContent = message || "";
      messageBox.classList.toggle("error", Boolean(isError));
    }

    function normalizeName(value) {
      return typeof value === "string" && value.trim() ? value.trim().toLowerCase() : null;
    }

    function dedupeRoster(roster) {
      const seen = new Set();
      const result = [];

      (Array.isArray(roster) ? roster : []).forEach((player) => {
        if (!player || typeof player !== "object") {
          return;
        }
        const nameKey = normalizeName(player.name);
        const idKey = normalizeName(player.steamid || player.steamId || player.id);
        const dedupeKey = nameKey || idKey;
        if (dedupeKey && seen.has(dedupeKey)) {
          return;
        }
        if (dedupeKey) {
          seen.add(dedupeKey);
        }
        result.push(player);
      });

      return result;
    }

    function buildRosterIndex(roster) {
      const index = new Map();
      roster.forEach((player) => {
        const key = normalizeName(player?.name);
        if (key && !index.has(key)) {
          index.set(key, player);
        }
      });
      return index;
    }

    function getForcedFallbackSet() {
      const result = new Set();
      if (!Array.isArray(forcedFallbackList)) {
        return result;
      }
      forcedFallbackList.forEach((value) => {
        const key = normalizeName(value);
        if (key) {
          result.add(key);
        }
      });
      return result;
    }

    function lookupRosterEntry(rosterIndex, nickname) {
      const key = normalizeName(nickname);
      if (key && rosterIndex.has(key)) {
        return rosterIndex.get(key);
      }
      return null;
    }

    function formatDate(isoString) {
      if (!isoString) {
        return "--";
      }
      try {
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return isoString;
        }
        return date.toLocaleString();
      } catch (error) {
        return isoString;
      }
    }

    function renderNav(links) {
      navLinks.innerHTML = "";
      links.forEach((link) => {
        const anchor = document.createElement("a");
        anchor.href = link.href;
        anchor.textContent = link.label;
        anchor.target = "_blank";
        anchor.rel = "noreferrer";
        navLinks.appendChild(anchor);
      });
    }

    function renderIps(items) {
      ipTableBody.innerHTML = "";

      if (!items.length) {
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = 4;
        cell.textContent = "No IPs yet";
        cell.style.color = "var(--muted)";
        row.appendChild(cell);
        ipTableBody.appendChild(row);
        return;
      }

      items.forEach((entry) => {
        const row = document.createElement("tr");

        const ipCell = document.createElement("td");
        ipCell.textContent = entry.ip;
        row.appendChild(ipCell);

        const labelCell = document.createElement("td");
        labelCell.textContent = entry.label || "--";
        row.appendChild(labelCell);

        const dateCell = document.createElement("td");
        dateCell.textContent = formatDate(entry.addedAt);
        row.appendChild(dateCell);

        const actionCell = document.createElement("td");
        if (entry.ip !== ownerIp) {
          const removeBtn = document.createElement("button");
          removeBtn.className = "danger";
          removeBtn.type = "button";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => handleRemoveIp(entry.ip));
          actionCell.appendChild(removeBtn);
        } else {
          const badge = document.createElement("span");
          badge.className = "tag";
          badge.textContent = "Primary";
          actionCell.appendChild(badge);
        }
        row.appendChild(actionCell);

        ipTableBody.appendChild(row);
      });
    }

    function renderActiveCameras(publishers, rosterIndex, roster) {
      cameraTableBody.innerHTML = "";

      const publisherEntries = Array.isArray(publishers) ? [...publishers] : [];
      const rosterEntries = Array.isArray(roster) ? [...roster] : [];
      const forcedSet = getForcedFallbackSet();
      const totalPlayers = rosterEntries.length;

      cameraCount.textContent = totalPlayers ? `${publisherEntries.length} / ${totalPlayers}` : `${publisherEntries.length}`;

      const combined = [];
      const seen = new Set();
      const rosterKey = (player) => {
        if (!player || typeof player !== "object") {
          return null;
        }
        return (
          normalizeName(player.name) ||
          normalizeName(player.steamid || player.steamId || player.id)
        );
      };

      publisherEntries.forEach((publisher) => {
        const nickname = typeof publisher?.nickname === "string" && publisher.nickname.trim()
          ? publisher.nickname.trim()
          : "--";
        const normalizedNickname = normalizeName(nickname);
        const rosterEntry = lookupRosterEntry(rosterIndex, nickname) || null;
        const rosterEntryKey = rosterKey(rosterEntry);

        combined.push({
          nickname,
          rosterEntry,
          publisher,
          isForced: normalizedNickname ? forcedSet.has(normalizedNickname) : false,
          viewerCount: publisher?.uniqueViewers ?? publisher?.connections ?? 0,
        });

        if (normalizedNickname) {
          seen.add(normalizedNickname);
        }
        if (rosterEntryKey) {
          seen.add(rosterEntryKey);
        }
      });

      rosterEntries.forEach((player) => {
        const playerName = typeof player?.name === "string" && player.name.trim() ? player.name.trim() : "--";
        const normalizedName = normalizeName(playerName);
        const key = rosterKey(player) || normalizedName;
        if (key && seen.has(key)) {
          return;
        }

        combined.push({
          nickname: playerName,
          rosterEntry: player,
          publisher: null,
          isForced: false,
          viewerCount: 0,
        });

        if (key) {
          seen.add(key);
        }
      });

      if (!combined.length) {
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = 5;
        cell.textContent = "No players found";
        cell.style.color = "var(--muted)";
        row.appendChild(cell);
        cameraTableBody.appendChild(row);
        return;
      }

      combined.sort((a, b) => {
        const rosterA = a.rosterEntry || lookupRosterEntry(rosterIndex, a.nickname) || {};
        const rosterB = b.rosterEntry || lookupRosterEntry(rosterIndex, b.nickname) || {};
        const teamA = (rosterA.team || "").toUpperCase();
        const teamB = (rosterB.team || "").toUpperCase();
        if (teamA !== teamB) {
          return teamA.localeCompare(teamB);
        }
        const slotA = Number(rosterA.observer_slot);
        const slotB = Number(rosterB.observer_slot);
        const validA = Number.isFinite(slotA) ? slotA : 999;
        const validB = Number.isFinite(slotB) ? slotB : 999;
        if (validA !== validB) {
          return validA - validB;
        }
        const nickA = typeof a.nickname === "string" ? a.nickname : "";
        const nickB = typeof b.nickname === "string" ? b.nickname : "";
        return nickA.localeCompare(nickB);
      });

      combined.forEach((entry) => {
        const { nickname, rosterEntry, publisher, isForced, viewerCount } = entry;

        const row = document.createElement("tr");

        const nameCell = document.createElement("td");
        nameCell.textContent = nickname;
        row.appendChild(nameCell);

        const teamCell = document.createElement("td");
        teamCell.textContent = (rosterEntry?.team || "").toUpperCase() || "--";
        row.appendChild(teamCell);

        const slotCell = document.createElement("td");
        const slotValue = Number(rosterEntry?.observer_slot);
        slotCell.textContent = Number.isFinite(slotValue) && slotValue > 0 ? String(slotValue) : "--";
        row.appendChild(slotCell);

        const statusCell = document.createElement("td");
        if (publisher) {
          statusCell.textContent = isForced ? `Live (MJPEG, ${viewerCount} viewers)` : `Live (${viewerCount} viewers)`;
          statusCell.style.color = "var(--success)";
        } else {
          statusCell.textContent = "Not streaming";
          statusCell.style.color = "var(--muted)";
        }
        row.appendChild(statusCell);

        const actionCell = document.createElement("td");
        if (publisher && nickname !== "--") {
          const fallbackBtn = document.createElement("button");
          fallbackBtn.className = "secondary";
          fallbackBtn.type = "button";
          fallbackBtn.textContent = isForced ? "Use WebRTC" : "Force MJPEG";
          fallbackBtn.addEventListener("click", () => handleForceFallback(nickname, !isForced));
          actionCell.appendChild(fallbackBtn);

          const kickBtn = document.createElement("button");
          kickBtn.className = "danger";
          kickBtn.type = "button";
          kickBtn.textContent = "Kick";
          kickBtn.addEventListener("click", () => handleKick(nickname));
          actionCell.appendChild(kickBtn);
        }

        if (!actionCell.childElementCount) {
          actionCell.textContent = "--";
          actionCell.style.color = "var(--muted)";
        }

        row.appendChild(actionCell);
        cameraTableBody.appendChild(row);
      });
    }

    function renderServerRoster(roster, cameraNameSet) {
      rosterTableBody.innerHTML = "";
      const entries = Array.isArray(roster) ? [...roster] : [];

      if (!entries.length) {
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = 4;
        cell.textContent = "No roster data";
        cell.style.color = "var(--muted)";
        row.appendChild(cell);
        rosterTableBody.appendChild(row);
        return;
      }

      entries.sort((a, b) => {
        const teamA = (a?.team || "").toUpperCase();
        const teamB = (b?.team || "").toUpperCase();
        if (teamA !== teamB) {
          return teamA.localeCompare(teamB);
        }
        const slotA = Number(a?.observer_slot);
        const slotB = Number(b?.observer_slot);
        const validA = Number.isFinite(slotA) ? slotA : 999;
        const validB = Number.isFinite(slotB) ? slotB : 999;
        if (validA !== validB) {
          return validA - validB;
        }
        const nameA = typeof a?.name === "string" ? a.name : "";
        const nameB = typeof b?.name === "string" ? b.name : "";
        return nameA.localeCompare(nameB);
      });

      entries.forEach((player) => {
        const row = document.createElement("tr");
        const playerName = typeof player?.name === "string" && player.name.trim() ? player.name.trim() : "--";
        const teamValue = (player?.team || "").toUpperCase();
        const slotValue = Number(player?.observer_slot);
        const steamId = player?.steamid || player?.steamId || player?.id || "--";
        const nameKey = normalizeName(playerName);

        const nameCell = document.createElement("td");
        nameCell.textContent = playerName;
        if (nameKey && cameraNameSet.has(nameKey)) {
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = "camera";
          nameCell.appendChild(badge);
        }
        row.appendChild(nameCell);

        const teamCell = document.createElement("td");
        teamCell.textContent = teamValue || "--";
        row.appendChild(teamCell);

        const slotCell = document.createElement("td");
        slotCell.textContent = Number.isFinite(slotValue) && slotValue > 0 ? String(slotValue) : "--";
        row.appendChild(slotCell);

        const steamCell = document.createElement("td");
        steamCell.textContent = steamId;
        row.appendChild(steamCell);

        rosterTableBody.appendChild(row);
      });
    }

    async function handleRemoveIp(ip) {
      if (!window.confirm(`Remove ${ip} from the allowlist?`)) {
        return;
      }
      try {
        const response = await fetch(`${ADD_IP_ENDPOINT}/${encodeURIComponent(ip)}`, {
          method: "DELETE",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to remove IP");
        }
        setMessage(`Removed ${ip} from the allowlist.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to remove IP", true);
      }
    }

    async function handleKick(nickname) {
      if (!window.confirm(`Kick camera for ${nickname}?`)) {
        return;
      }
      try {
        const response = await fetch(KICK_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nickname }),
          credentials: "include",
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to kick camera");
        }
        setMessage(`Camera ${nickname} disconnected.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to kick camera", true);
      }
    }

    async function handleForceFallback(nickname, enable) {
      const trimmed = typeof nickname === "string" ? nickname.trim() : "";
      if (!trimmed) {
        return;
      }

      const mode = enable ? "mjpeg" : "auto";
      try {
        const response = await fetch(FALLBACK_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nickname: trimmed, mode }),
          credentials: "include",
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to update fallback");
        }
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to update fallback", true);
      }
    }

    document.getElementById("addIpForm").addEventListener("submit", async (event) => {
      event.preventDefault();
      const ip = event.target.ip.value.trim();
      const label = event.target.label.value.trim();
      if (!ip) {
        setMessage("Enter an IPv4 address", true);
        return;
      }
      try {
        const response = await fetch(ADD_IP_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ip, label }),
          credentials: "include",
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to add IP");
        }
        event.target.reset();
        setMessage(`Added ${ip} to the allowlist.`);
        await loadDashboard();
      } catch (error) {
        setMessage(error.message || "Failed to add IP", true);
      }
    });

    async function loadDashboard() {
      try {
        const response = await fetch(DASHBOARD_ENDPOINT, {
          cache: "no-store",
          credentials: "include",
        });
        if (!response.ok) {
          const payload = await response.json().catch(() => ({}));
          throw new Error(payload.error || "Failed to load dashboard");
        }

        const data = await response.json();
        ownerIp = data.ownerIp;
        const focus = data.currentFocus || null;
        focusName.textContent = focus || "--";
        updatedAt.textContent = formatDate(data.updatedAt);
        forcedFallbackList = Array.isArray(data.forcedFallback) ? data.forcedFallback : [];
        renderNav(Array.isArray(data.siteLinks) ? data.siteLinks : []);
        renderIps(Array.isArray(data.allowedIps) ? data.allowedIps : []);

        const roster = dedupeRoster(Array.isArray(data.roster) ? data.roster : []);
        const rosterIndex = buildRosterIndex(roster);
        const publishers = Array.isArray(data.publishers) ? data.publishers : [];
        const cameraNameSet = new Set();
        publishers.forEach((entry) => {
          const key = normalizeName(entry?.nickname);
          if (key) {
            cameraNameSet.add(key);
          }
        });

        renderActiveCameras(publishers, rosterIndex, roster);
        renderServerRoster(roster, cameraNameSet);
      } catch (error) {
        setMessage(error.message || "Dashboard connection failed", true);
      }
    }

    loadDashboard();
    setInterval(loadDashboard, 5000);
  </script>
</body>
</html>
